<!DOCTYPE html><head><meta charset="UTF-8"><title>Constraints System | Zapdos</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/zapdos.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Zapdos</a><a href="https://github.com/shannon-lab/zapdos" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="95be1047-914f-4099-ad0e-af9fa10bedc9" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="a9cabd95-25c4-42bb-8350-de8fb41e8af8" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="e425f59d-ef5f-49ec-8caa-9bd1a4823414" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#" class="sidenav-trigger" data-target="0095b505-b23a-467c-af4c-3b4116caa166"><i class="material-icons">menu</i></a><ul class="sidenav" id="0095b505-b23a-467c-af4c-3b4116caa166"><li><a href="#!" class="dropdown-trigger" data-target="b286ada7-c53d-457d-8713-7ebc3c2744ef" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="b76b9a70-1b3f-4b1e-ac3d-f195f31ae3f0" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="9aab12ca-7a51-4d77-ae0b-e0c69ce30e4d" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="95be1047-914f-4099-ad0e-af9fa10bedc9"><li><a href="../../getting_started/installation.html">Installation</a></li><li><a href="../../getting_started/using_zapdos.html">Using Zapdos</a></li><li><a href="../../getting_started/zapdos_meshing.html">Generating Meshes</a></li></ul><ul class="dropdown-content" id="a9cabd95-25c4-42bb-8350-de8fb41e8af8"><li><a href="../index.html">Complete Code Syntax</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/libmesh/classes.html">libMesh Doxygen</a></li><li><a href="../../a-to-z.html">Zapdos A to Z Index</a></li><li><a href="../../development/contributing.html">Contributing Guidelines</a></li><li><a href="../../development/code_standards.html">Code Standards</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="e425f59d-ef5f-49ec-8caa-9bd1a4823414"><li><a href="https://github.com/shannon-lab/zapdos/discussions">Zapdos Discussions Forum</a></li><li><a href="../../development/zapdos_developer_info.html">Zapdos Developer Information</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussions Forum</a></li><li><a href="https://mooseframework.inl.gov/">MOOSE Homepage</a></li><li><a href="../../development/moose_developer_info.html">MOOSE Developer Information</a></li></ul><ul class="dropdown-content" id="b286ada7-c53d-457d-8713-7ebc3c2744ef"><li><a href="../../getting_started/installation.html">Installation</a></li><li><a href="../../getting_started/using_zapdos.html">Using Zapdos</a></li><li><a href="../../getting_started/zapdos_meshing.html">Generating Meshes</a></li></ul><ul class="dropdown-content" id="b76b9a70-1b3f-4b1e-ac3d-f195f31ae3f0"><li><a href="../index.html">Complete Code Syntax</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/libmesh/classes.html">libMesh Doxygen</a></li><li><a href="../../a-to-z.html">Zapdos A to Z Index</a></li><li><a href="../../development/contributing.html">Contributing Guidelines</a></li><li><a href="../../development/code_standards.html">Code Standards</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="9aab12ca-7a51-4d77-ae0b-e0c69ce30e4d"><li><a href="https://github.com/shannon-lab/zapdos/discussions">Zapdos Discussions Forum</a></li><li><a href="../../development/zapdos_developer_info.html">Zapdos Developer Information</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussions Forum</a></li><li><a href="https://mooseframework.inl.gov/">MOOSE Homepage</a></li><li><a href="../../development/moose_developer_info.html">MOOSE Developer Information</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">syntax</a><a href="." class="breadcrumb">Constraints</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="124e0086-267d-45aa-8063-1f5f6c260f93" data-section-level="1" data-section-text="Constraints System"><h1 id="constraints-system">Constraints System</h1><section class="scrollspy" id="b8fd0cd9-228a-466e-b971-d3a0323ccacc" data-section-level="2" data-section-text="MortarConstraints"><h2 id="mortarconstraints">MortarConstraints</h2><p>The mortar system in MOOSE uses a segment-based approach for evaluation of mortar integrals; for information on the automatic generation of mortar segment meshes see <a href="../../source/constraints/AutomaticMortarGeneration.html">AutomaticMortarGeneration</a>.</p><section id="1c1d7486-e118-488c-b1d7-85ae3cd32bcf" data-section-level="3" data-section-text="Overview"><h3 id="overview">Overview</h3><p>An excellent overview of the conservative mortar constraint implementation in MOOSE for 2D problems is given in <a href="#osti_1468630">Peterson (2018)</a>. We have verified that the MOOSE mortar implementation satisfies the following <em>a priori</em> error estimates for 2D problems and (see discussion and plots on <a href="https://github.com/idaholab/moose/issues/13080">this github issue</a>) and for 3D problems on <em>hexahedral</em> meshes:</p><div form="['center', 'center', 'center', 'center']" recursive class="moose-table-div"><table><thead><tr><th style=";text-align:center">Primal FE Type</th><th style=";text-align:center">Lagrange Multiplier (LM) FE Type</th><th style=";text-align:center">Primal L2 Convergence Rate</th><th style=";text-align:center">LM L2 Convergence Rate</th></tr></thead><tbody><tr><td style=";text-align:center">Second order Lagrange</td><td style=";text-align:center">First order Lagrange</td><td style=";text-align:center">3</td><td style=";text-align:center">2.5</td></tr></tbody><tbody><tr><td style=";text-align:center">Second order Lagrange</td><td style=";text-align:center">Constant monomial</td><td style=";text-align:center">3</td><td style=";text-align:center">1</td></tr></tbody><tbody><tr><td style=";text-align:center">First order Lagrange</td><td style=";text-align:center">First order Lagrange</td><td style=";text-align:center">2</td><td style=";text-align:center">1.5</td></tr></tbody><tbody><tr><td style=";text-align:center">First order Lagrange</td><td style=";text-align:center">Constant monomial</td><td style=";text-align:center">2</td><td style=";text-align:center">1.5</td></tr></tbody></table></div><p>General meshes in 3D—especially meshes with triangular face elements on the mortar interface—require additional care to ensure convergence. Triangular elements on the mortar interface typically exhibit the infamous (and well documented) &#x27;locking&#x27; phenomenon; resulting in singular systems that require stabilization or other special treatment.</p><p>The above <em>primal</em> convergence rates were realized on tetrahedral and mixed meshes using a stabilization with <code>delta = 0.1</code> for the <code>EqualValueConstraint</code>, with the additional caveat that meshes (both generated and unstructured) are re-generated for each experiment. Uniform refinement of tetrahedral meshes were typically observed to result in <em>divergence</em> of the Lagrange multiplier and degradation of primal convergence rates. Adaptive refinement of meshes with triangular faces on the mortar interface has not been thoroughly studied in MOOSE and should be approached with caution.</p><p>Based on these observations the following recommendations are provided for using <em>3D</em> mortar in MOOSE:</p><ol class="browser-default" start="1"><li><p>When possible, discretize the secondary side of the mortar interface with QUAD elements (i.e. use HEX elements or carefully oriented PRISM and PYRAMID elements for volume discretization). </p></li><li><p>When TRI elements are present on the mortar interface, verify that the problem is well conditioned of the problem and use stabilization if necessary. </p></li><li><p>Avoid uniformly refining meshes, instead regenerate meshes when a refined mesh is needed.</p></li></ol><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note</span></div><div class="card-content"><div class="moose-alert-content"><p>3D mortar often requires larger AD array sizes than specified by the default MOOSE configuration. To configure MOOSE with a larger array use configuration option <code>--with-derivative-size=&lt;n&gt;</code>. The AD size required for a problem depends on 1) problem physics, 2) the order of primal and Lagrange multiplier variables, and 3) the relative sizing of the secondary and primary meshes.</p></div></div></div></section><section id="485a6395-2550-46cd-9ef7-fa3d7062804c" data-section-level="3" data-section-text="Parameters"><h3 id="parameters">Parameters</h3><p>There are four required parameters the user will always have to supply for a constraint derived from <code>MortarConstraint</code>:</p><ul class="browser-default"><li><p><code>primary_boundary</code>: the boundary name or ID assigned to the primary side of the mortar interface </p></li><li><p><code>secondary_boundary</code>: the boundary name or ID assigned to the secondary side of the mortar interface </p></li><li><p><code>primary_subdomain</code>: the subdomain name or ID assigned to the lower-dimensional block on the primary side of the mortar interface </p></li><li><p><code>secondary_boundary</code>: the subdomain name or ID assigned to the lower-dimensional block on the secondary side of the mortar interface</p></li></ul><p>As suggested by the above required parameters, the user must do some mesh work before they can use a <code>MortarConstraint</code> object. The easiest way to prepare the mesh is to assign boundary IDs to the secondary and primary sides of the interface when creating the mesh in their 3rd-party meshing software (e.g. Cubit or Gmsh). If these boundary IDs exist, then the lower dimensional blocks can be generated automatically using the <code>LowerDBlockFromSidesetGenerator</code> mesh generator as shown in the below input file snippet:</p><pre class="moose-pre"><code class="language-text">
[Mesh]
  [./primary]
    type = LowerDBlockFromSidesetGenerator
    sidesets = &#x27;2&#x27;
    new_block_id = &#x27;20&#x27;
  [../]
  [./secondary]
    type = LowerDBlockFromSidesetGenerator
    sidesets = &#x27;1&#x27;
    new_block_id = &#x27;10&#x27;
  [../]
[]
</code></pre><p>There are also some optional parameters that can be supplied to <code>MortarConstraints</code>. They are:</p><ul class="browser-default"><li><p><code>variable</code>: Corresponds to a Lagrange Multiplier variable that lives on the lower dimensional block on the secondary face </p></li><li><p><code>secondary_variable</code>: Primal variable on the secondary side of the mortar interface (lives on the interior elements) </p></li><li><p><code>primary_variable</code>: Primal variable on the primary side of the mortar interface (lives on the interior elements). Most often <code>secondary_variable</code> and <code>primary_variable</code> will correspond to the same variable </p></li><li><p><code>compute_lm_residuals</code>: Whether to compute Lagrange Multiplier residuals. This will automatically be set to false if a <code>variable</code> parameter is not supplied. Other cases where the user may want to set this to false is when a different geometric algorithm is used for computing residuals for the LM and primal variables. For example, in mechanical contact the Karush-Kuhn-Tucker conditions may be enforced at nodes (through perhaps a <code>NodeFaceConstraint</code>) whereas the contact forces may be applied to the displacement residuals through <code>MortarConstraint</code> </p></li><li><p><code>compute_primal_residuals</code>: Whether to compute residuals for the primal variables. Again this may be a useful parameter to use when applying different geometric algorithms for computing residuals for LM variables and primal variables. </p></li><li><p><code>periodic</code>: Whether this constraint is going to be used to enforce a periodic condition. This has the effect of changing the normals vector, for mortar projection, from outward to inward facing. </p></li><li><p><code>quadrature</code>: Specifies the quadrature order for mortar segment elements. This is only useful for 3D mortar on QUAD face elements since integration of QUAD face elements with TRI mortar segments on the mortar interface is inexact. Default quadratures are typically sufficient, but <em>exact</em> integration of FIRST order QUAD face elements (e.g. HEX8 meshes) requires SECOND order integration. <em>Exact</em> integration of SECOND order QUAD face elements (e.g. HEX27 meshes) requires FOURTH order integration.</p></li></ul><p>At present, either the <code>secondary_variable</code> or <code>primary_variable</code> parameter must be supplied.</p></section></section><section class="scrollspy" id="9a9b437d-1ff2-4bcf-ab7d-33d0036527e7" data-section-level="2" data-section-text="Available Objects"><h2 id="available-objects">Available Objects</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/constraints/PenaltyEqualValueConstraint.html">ADPenaltyEqualValueConstraint</a>PenaltyEqualValueConstraint enforces solution continuity between secondary and primary sides of a mortar interface using a penalty approach (no Lagrange multipliers needed)</li><li class="collection-item"><a href="../../source/constraints/CoupledTiedValueConstraint.html">CoupledTiedValueConstraint</a>Requires the value of two variables to be the consistent on both sides of an interface.</li><li class="collection-item"><a href="../../source/constraints/EqualGradientConstraint.html">EqualGradientConstraint</a>EqualGradientConstraint enforces continuity of a gradient component between secondary and primary sides of a mortar interface using lagrange multipliers</li><li class="collection-item"><a href="../../source/constraints/EqualValueBoundaryConstraint.html">EqualValueBoundaryConstraint</a>Constraint for enforcing that variables on each side of a boundary are equivalent.</li><li class="collection-item"><a href="../../source/constraints/EqualValueConstraint.html">EqualValueConstraint</a>EqualValueConstraint enforces solution continuity between secondary and primary sides of a mortar interface using lagrange multipliers</li><li class="collection-item"><a href="../../source/constraints/EqualValueEmbeddedConstraint.html">EqualValueEmbeddedConstraint</a>This is a constraint enforcing overlapping portions of two blocks to have the same variable value</li><li class="collection-item"><a href="../../source/constraints/LinearNodalConstraint.html">LinearNodalConstraint</a>Constrains secondary node to move as a linear combination of primary nodes.</li><li class="collection-item"><a href="../../source/constraints/OldEqualValueConstraint.html">OldEqualValueConstraint</a>OldEqualValueConstraint enforces solution continuity between secondary and primary sides of a mortar interface using lagrange multipliers</li><li class="collection-item"><a href="../../source/constraints/PenaltyEqualValueConstraint.html">PenaltyEqualValueConstraint</a>PenaltyEqualValueConstraint enforces solution continuity between secondary and primary sides of a mortar interface using a penalty approach (no Lagrange multipliers needed)</li><li class="collection-item"><a href="../../source/constraints/TiedValueConstraint.html">TiedValueConstraint</a>Constraint that forces the value of a variable to be the same on both sides of an interface.</li><li class="collection-header">Zapdos App</li><li class="collection-item"><a href="../../source/constraints/ArbitrarilyTiedValueConstraint.html">ArbitrarilyTiedValueConstraint</a></li></ul></section><section class="scrollspy" id="867eaabb-9518-462c-a707-0f6132183bf3" data-section-level="2" data-section-text="Available Actions"><h2 id="available-actions">Available Actions</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/actions/AddConstraintAction.html">AddConstraintAction</a>Add a Constraint object to the simulation.</li></ul></section><section class="scrollspy" id="fa77e13b-7c96-4e5a-8147-5a3015552786" data-section-level="2" data-section-text="References"><h2 id="references">References</h2><div class="moose-bibliography"><ol><li id="osti_1468630">John&nbsp;W. Peterson.
Progress toward a new implementation of the mortar finite element method in moose.
2 2018.
<a href="https://doi.org/10.2172/1468630">doi:10.2172/1468630</a>.<a href="#c63af062-4132-432c-9ed3-e40da740e144" class="modal-trigger moose-bibtex-modal" style="padding-left:10px;">[BibTeX]</a><div class="modal" id="c63af062-4132-432c-9ed3-e40da740e144"><div class="modal-content"><pre style="line-height:1.25;"><code class="language-latex">@article{osti_1468630,
    author = "Peterson, John W.",
    title = "Progress toward a new implementation of the mortar finite element method in MOOSE",
    abstractNote = {The mortar finite element method has been used for many years in a variety of applications, including the enforcement of continuity conditions across decomposed domains, the implementation of Dirichlet boundary conditions, obtaining improved estimates of surface fluxes, and for solving large deformation contact mechanics problems. There is a currently great deal of interest in developing more robust mechanical and thermal contact solution strategies in the MOOSE framework and physics modules, and schemes based on the mortar finite element approach appear to be a promising avenue of development. There are a number of challenges associated with the development of a robust Lagrange multiplier based formulation of the mortar finite element method which can be tackled using the relatively simple framework of thermal contact problems, before tackling more complicated applications such as thermomechanical contact. In this report, we describe several aspects of our mortar finite element method implementation for solving thermal contact problems. The approach and notation used are based primarily based on the work of Bin Yang et al. ("Two dimensional mortar contact methods for large deformation frictional sliding," International Journal for Numerical Methods in Engineering 62(9), 2005).},
    doi = "10.2172/1468630",
    journal = "",
    place = "United States",
    year = "2018",
    month = "2"
}
</code></pre></div></div></li></ol></div></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#b8fd0cd9-228a-466e-b971-d3a0323ccacc" class="tooltipped" data-position="left" data-tooltip="MortarConstraints">MortarConstraints</a></li><li><a href="#9a9b437d-1ff2-4bcf-ab7d-33d0036527e7" class="tooltipped" data-position="left" data-tooltip="Available Objects">Available Objects</a></li><li><a href="#867eaabb-9518-462c-a707-0f6132183bf3" class="tooltipped" data-position="left" data-tooltip="Available Actions">Available Actions</a></li><li><a href="#fa77e13b-7c96-4e5a-8147-5a3015552786" class="tooltipped" data-position="left" data-tooltip="References">References</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>