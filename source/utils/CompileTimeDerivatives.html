<!DOCTYPE html><head><meta charset="UTF-8"><title>Compile time Derivatives | Zapdos</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/zapdos.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Zapdos</a><a href="https://github.com/shannon-lab/zapdos" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="58f70c30-47b4-4a60-9c3b-a63411ca7b37" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="ec3a0c6a-1faa-4dcf-b148-866e2451a96d" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="6fd08b20-979b-49ea-bb04-29edde26193e" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#" class="sidenav-trigger" data-target="fbfa35d8-0926-46c0-9186-7ed8a3d24969"><i class="material-icons">menu</i></a><ul class="sidenav" id="fbfa35d8-0926-46c0-9186-7ed8a3d24969"><li><a href="#!" class="dropdown-trigger" data-target="3b140988-394c-4dbb-8b81-4fa1cd82fe30" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="530ac89d-56ed-4c71-9841-9944c0b26a24" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="fdd95b0a-3901-4591-8052-361027d161eb" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="58f70c30-47b4-4a60-9c3b-a63411ca7b37"><li><a href="../../getting_started/installation.html">Installation</a></li><li><a href="../../getting_started/using_zapdos.html">Using Zapdos</a></li><li><a href="../../getting_started/zapdos_meshing.html">Generating Meshes</a></li><li><a href="../../tutorial/index.html">Tutorial Slides</a></li></ul><ul class="dropdown-content" id="ec3a0c6a-1faa-4dcf-b148-866e2451a96d"><li><a href="../../syntax/zapdos_only.html">Zapdos Input Syntax</a></li><li><a href="../../syntax/index.html">Complete Code Syntax</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/libmesh/classes.html">libMesh Doxygen</a></li><li><a href="../../a-to-z.html">Zapdos A to Z Index</a></li><li><a href="../../examples/crane_examples.html">CRANE Examples</a></li><li><a href="../../development/contributing.html">Contributing Guidelines</a></li><li><a href="../../development/code_standards.html">Code Standards</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="6fd08b20-979b-49ea-bb04-29edde26193e"><li><a href="https://github.com/shannon-lab/zapdos/discussions">Zapdos Discussions Forum</a></li><li><a href="../../development/zapdos_developer_info.html">Zapdos Developer Information</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussions Forum</a></li><li><a href="https://mooseframework.inl.gov/">MOOSE Homepage</a></li><li><a href="../../development/moose_developer_info.html">MOOSE Developer Information</a></li></ul><ul class="dropdown-content" id="3b140988-394c-4dbb-8b81-4fa1cd82fe30"><li><a href="../../getting_started/installation.html">Installation</a></li><li><a href="../../getting_started/using_zapdos.html">Using Zapdos</a></li><li><a href="../../getting_started/zapdos_meshing.html">Generating Meshes</a></li><li><a href="../../tutorial/index.html">Tutorial Slides</a></li></ul><ul class="dropdown-content" id="530ac89d-56ed-4c71-9841-9944c0b26a24"><li><a href="../../syntax/zapdos_only.html">Zapdos Input Syntax</a></li><li><a href="../../syntax/index.html">Complete Code Syntax</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/libmesh/classes.html">libMesh Doxygen</a></li><li><a href="../../a-to-z.html">Zapdos A to Z Index</a></li><li><a href="../../examples/crane_examples.html">CRANE Examples</a></li><li><a href="../../development/contributing.html">Contributing Guidelines</a></li><li><a href="../../development/code_standards.html">Code Standards</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="fdd95b0a-3901-4591-8052-361027d161eb"><li><a href="https://github.com/shannon-lab/zapdos/discussions">Zapdos Discussions Forum</a></li><li><a href="../../development/zapdos_developer_info.html">Zapdos Developer Information</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussions Forum</a></li><li><a href="https://mooseframework.inl.gov/">MOOSE Homepage</a></li><li><a href="../../development/moose_developer_info.html">MOOSE Developer Information</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">utils</span><a href="#" class="breadcrumb">CompileTimeDerivatives</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="06f74ff8-f51a-48fd-bc8d-0b7091a5c9a3" data-section-level="1" data-section-text="Compile - time Derivatives"><h1 id="compile-time-derivatives">Compile-time Derivatives</h1><p><code>CompileTimeDerivatives</code> (CTD) is a C++ namespace containing classes, functions, and operators to implement mathematical expressions with the ability to perform symbolic automatic differentiation at compile time. It is a replacement for the runtime automatic differentiation in <code>ExpressionBuilder</code> which uses a convoluted process to arrive at compiled mathematical expressions and their derivatives.</p><section class="scrollspy" id="b9322005-eec8-4a1b-b2e6-13bfe5b8ffc7" data-section-level="2" data-section-text="Uses"><h2 id="uses">Uses</h2><p>The intended uses for the CTD framework are the implementation of empirical or analytical models with closed form expressions that compute quantities of which derivatives are required. Examples are</p><ol class="browser-default" start="1"><li><p>Thermodynamic free energies, the derivatives of which are chemical potentials, which are required to solve the phase field equations. </p></li><li><p>A thermal conductivity as a function of temperature, where the derivative w.r.t. temperature is required in the heat transfer equations.</p></li></ol><p>CTD is not meant to replace runtime AD using dual numbers (which computes derivatives w.r.t. degrees of freedom). Any application that requires the construction of symbolic derivatives of equations w.r.t. known coupled variables, can be simplified with CTD.</p></section><section class="scrollspy" id="431567aa-1e7c-4a25-9072-3f1d12b32fa2" data-section-level="2" data-section-text="Examples"><h2 id="examples">Examples</h2><p>Constructing an expression and taking its derivative.</p><p>Create a _tag_ that will identify the variable</p><pre style="max-height:350px;"><code class="language-cpp">
  enum
  {
    dX
  };
</code></pre><p>Connect a C++ variable and a _tag_ to obtain a compile time derivative reference object that will evaluate as the C++ variable value:</p><pre style="max-height:350px;"><code class="language-cpp">
  Real x;
  const auto X = makeRef&lt;dX&gt;(x);
</code></pre><p>Build an expression for <code>x^2+100</code>:</p><pre style="max-height:350px;"><code class="language-cpp">
  const auto result = X * X + 100.0;
</code></pre><p>Evaluate the expression for x=5:</p><pre style="max-height:350px;"><code class="language-text">
  x = 5;
  Moose::out &lt;&lt; result() &lt;&lt; &#x27;\n&#x27;; // 125.0
</code></pre><p>And evaluate the derivative w.r.t. <code>x</code> at x=5:</p><pre style="max-height:350px;"><code class="language-text">
  Moose::out &lt;&lt; result.D&lt;dX&gt;()() &lt;&lt; &#x27;\n&#x27;; // 10.0
</code></pre><p>Note that there is no runtime cost to calling <code>.D&lt;dX&gt;()</code>. The derivatives are taken at compile time.</p><p>The unit tests contain more examples on how to use the system.</p><pre style="max-height:350px;"><code class="language-cpp">
#include &quot;gtest/gtest.h&quot;

// Moose includes
#include &quot;MooseTypes.h&quot;
#include &quot;CompileTimeDerivatives.h&quot;

using namespace CompileTimeDerivatives;

TEST(CompileTimeDerivativesTest, simple)
{
  // this test serves as a simple example for the compile time derivative system

  // a variable to be used in the expression evaluation
  Real my_x = 1.0;

  // use an enum to use symbols for tags
  enum
  {
    dx
  };

  // we wrap this variable in a reference node that we tag with the `dx` enum
  const auto x = makeRef&lt;dx&gt;(my_x);

  // now we build an expression that uses our variable x
  // the expression is not yet evaluated
  const auto result = (x + 2) * (x + 3);

  // when evaluated this expression should always return (1+2)*(1*3) = 12
  // we evaluate the result using the () operator
  EXPECT_NEAR(result(), 12, 1e-10);

  // we can build the derivative using the D&lt;&gt;() function. The template parameter
  // is the tag we want to take the derivative w.r.t.
  const auto dx_result = result.D&lt;dx&gt;();

  // the derivative of the above expression is 1*(x+3)+(x+2)*1 = 2x+5
  // let&#x27;s set our original variable to 2
  my_x = 2.0;

  // if we re-evaluate the original expression we should get an updated result
  // of (2+2)*(2*3) = 20
  EXPECT_NEAR(result(), 20, 1e-10);

  // and for the derivative we expect 2*2+5 = 9
  EXPECT_NEAR(dx_result(), 9, 1e-10);
}

#define CTD_EVALTEST(expression, v0, v1, dv)                                                       \
  for (Real v = v0; v &lt;= v1; v += dv)                                                              \
  {                                                                                                \
    Real r1, r2;                                                                                   \
    {                                                                                              \
      const auto x = makeRef&lt;1&gt;(v);                                                                \
      const auto result = expression;                                                              \
      r1 = result();                                                                               \
    }                                                                                              \
    {                                                                                              \
      const auto &amp; x = v;                                                                          \
      r2 = expression;                                                                             \
    }                                                                                              \
    EXPECT_NEAR(r1, r2, 1e-13);                                                                    \
  }

TEST(CompileTimeDerivativesTest, evaluate)
{
  CTD_EVALTEST(x, -10, 10, 0.72)
  CTD_EVALTEST(2 * x, -10, 10, 0.72)
  CTD_EVALTEST(2.0 * x, -10, 10, 0.72)
  CTD_EVALTEST(x * 3, -10, 10, 0.72)
  CTD_EVALTEST(x * -3.0, -10, 10, 0.72)
  CTD_EVALTEST(x + 1, -10, 10, 0.72)
  CTD_EVALTEST(x - 1.0, -10, 10, 0.72)
  CTD_EVALTEST(0.5 + x, -10, 10, 0.72)
  CTD_EVALTEST(0.75 - x, -10, 10, 0.72)
  CTD_EVALTEST(1.0 / x, -10, 10, 0.72)
  CTD_EVALTEST(x / 2.0, -10, 10, 0.72)
  CTD_EVALTEST(x + (2.0 / x), -10, 10, 0.72)
  CTD_EVALTEST(x * (1.0 + x), -10, 10, 0.72)

  CTD_EVALTEST(x * (1.0 + x * (3.0 - x * (2.0 + x * (5.0 - x)))), -10, 10, 0.63)

  CTD_EVALTEST(x * -1.0 &gt; x * -2.0, -10, 10, 0.63)
  CTD_EVALTEST(x * -1.0 &lt; x * -2.0, -10, 10, 0.63)
  CTD_EVALTEST(x * -1.0 &gt;= x * -2.0, -10, 10, 1)
  CTD_EVALTEST(x * -1.0 &lt;= x * -2.0, -10, 10, 1)
  CTD_EVALTEST(0.0 &lt; x, -1, 1, 1)
  CTD_EVALTEST(0.0 &gt; x, -1, 1, 1)
  CTD_EVALTEST(0.0 &lt;= x, -1, 1, 1)
  CTD_EVALTEST(0.0 &gt;= x, -1, 1, 1)
  CTD_EVALTEST(0.0 == x, -1, 1, 1)
  CTD_EVALTEST(0.0 != x, -1, 1, 1)

  using namespace std;
  CTD_EVALTEST(sin(x), -10, 10, 0.72)
  CTD_EVALTEST(cos(x), -10, 10, 0.72)
  CTD_EVALTEST(tan(x), -10, 10, 0.72)
  CTD_EVALTEST(exp(x), -2, 2, 0.1)
  CTD_EVALTEST(erf(x), -2, 2, 0.1)
  CTD_EVALTEST(log(x), 0.1, 10, 0.1)
  CTD_EVALTEST(tanh(x), -10, 10, 0.1)
  CTD_EVALTEST(sinh(x), -4, 4, 0.1)
  CTD_EVALTEST(cosh(x), -4, 4, 0.1)
  CTD_EVALTEST(atan(x), -4, 4, 0.1)

  CTD_EVALTEST(min(x, x * x), -2, 2, 0.271)
  CTD_EVALTEST(max(x, x * x), -2, 2, 0.271)

  const auto v = makeValue(0.5);
  const auto r1 = CompileTimeDerivatives::atan2(1.0, 2.0);
  const auto r2 = CompileTimeDerivatives::atan2(v, 2.0);
  const auto r3 = CompileTimeDerivatives::atan2(1.0, v);
  const auto r4 = CompileTimeDerivatives::atan2(v, v);
  EXPECT_NEAR(r1(), 0.46364760900080609, 1e-12);
  EXPECT_NEAR(r2(), 0.24497866312686414, 1e-12);
  EXPECT_NEAR(r3(), 1.1071487177940904, 1e-12);
  EXPECT_NEAR(r4(), 0.7853981633974482, 1e-12);
}

TEST(CompileTimeDerivativesTest, finitedifference)
{
  Real v = 0;
  const auto x = makeRef&lt;1&gt;(v);

  const auto test = [&amp;v](auto expr, Real v0, Real v1, Real dv, Real eps = 1e-6, Real err = 1e-6)
  {
    for (Real vv = v0; vv &lt;= v1; vv += dv)
    {
      v = vv;
      const auto df = expr.template D&lt;1&gt;()();
      v = vv - eps;
      const auto f0 = expr();
      v = vv + eps;
      const auto f1 = expr();
      const auto fd = (f1 - f0) / (2.0 * eps);
      EXPECT_NEAR(df, fd, err);
    }
  };

  test(x, -3, 3, 0.21);
  test(-x, -3, 3, 0.21);
  test(x * x, -3, 3, 0.21);
  test(pow(x, 3), -3, 3, 0.21);
  test(pow(5, x), -3, 3, 0.21);
  test(pow(x, 3.0), -3, 3, 0.21);
  test(pow(5.0, x), -3, 3, 0.21);
  test(pow(x, x), 0.1, 3, 0.21);
  test(pow&lt;4&gt;(x), -3, 3, 0.21);
  test(pow&lt;4&gt;(2), -1, 1, 0.4);
  test(sin(x), -3, 3, 0.21);
  test(-sin(x), -3, 3, 0.21);
  test(cos(x), -3, 3, 0.21);
  test(tan(x), -10, 10, 0.2, 1e-7);
  test(exp(x), -2, 2, 0.2);
  test(erf(x), -2, 2, 0.2);
  test(log(x), 0.1, 3, 0.1);
  test(tanh(x), -10, 10, 0.2, 1e-7);
  test(sinh(x), -4, 4, 0.2);
  test(cosh(x), -4, 4, 0.2);
  test(atan(x), -4, 4, 0.2);
  test(atan2(x, 1), -3, 3, 0.21);
  test(atan2(1, x), -3, 3, 0.21);
  test(atan2(sin(x), cos(x)), -3, 3, 0.2);
}

TEST(CompileTimeDerivativesTest, derivative)
{
  enum
  {
    dX
  };

  Real v = 0.0;
  const auto x = makeRef&lt;dX&gt;(v);
  const auto result = x * (1.0 - x) - (x * log(x) + (1.0 - x) * log(1.0 - x));

  Real r0 = 0, r1 = 0, r2 = 0;
  for (v = 0.01; v &lt;= 0.99; v += 0.01)
  {
    r0 += std::abs(result() - (v * (1.0 - v) - (v * std::log(v) + (1.0 - v) * std::log(1.0 - v))));
    r1 += std::abs(result.D&lt;dX&gt;()() -
                   (-2.0 * v - std::log(v) + std::log(1.0 - v) - (v - 1.0) / (1.0 - v)));
    r2 += std::abs(result.D&lt;dX&gt;().D&lt;dX&gt;()() - (-2.0 + 1.0 / (v - 1.0) - 1.0 / v));
  }
  EXPECT_NEAR(r0, 0, 1e-12);
  EXPECT_NEAR(r1, 0, 1e-12);
  EXPECT_NEAR(r2, 0, 1e-12);
}

TEST(CompileTimeDerivativesTest, variable_reference)
{
  enum
  {
    dX
  };

  Real x = 0.0;
  const auto X = makeRef&lt;dX&gt;(x);
  const auto result = X * X + 100.0;

  x = 5;
  EXPECT_EQ(result(), 125.0);
  EXPECT_EQ(result.D&lt;dX&gt;()(), 10.0);

  x = 3;
  EXPECT_EQ(result(), 109.0);
  EXPECT_EQ(result.D&lt;dX&gt;()(), 6.0);
}

TEST(CompileTimeDerivativesTest, vector_reference)
{
  enum
  {
    dX
  };

  std::vector&lt;double&gt; _prop{1, 2, 3, 4};
  std::size_t _qp = 0;

  const auto prop = makeRef&lt;dX&gt;(_prop, _qp);
  const auto result = 3.0 * prop * prop;

  _qp = 1;
  EXPECT_EQ(result(), 12.0);
  EXPECT_EQ(result.D&lt;dX&gt;()(), 12.0);
  EXPECT_EQ(result.D&lt;dX&gt;().D&lt;dX&gt;()(), 6.0);

  _qp = 3;
  EXPECT_EQ(result(), 48.0);
  EXPECT_EQ(result.D&lt;dX&gt;()(), 24.0);
  EXPECT_EQ(result.D&lt;dX&gt;().D&lt;dX&gt;()(), 6.0);
}

TEST(CompileTimeDerivativesTest, print)
{
  std::vector&lt;double&gt; _prop{1, 2, 3, 4};
  std::size_t _qp = 2;
  const auto prop = makeRef(_prop, _qp);
  const auto result1 = 3.0 * prop * prop;
  EXPECT_EQ(result1.print(), &quot;3*[a[2]]*[a[2]]&quot;);

  Real v = 0.0;
  const auto x = makeRef(v);
  const auto result2 = x * (1.0 - x) - (x * log(x) + (1.0 - x) * log(1.0 - x));
  EXPECT_EQ(result2.print(), &quot;[v]*(1-[v])-([v]*log([v])+(1-[v])*log(1-[v]))&quot;);
}

TEST(CompileTimeDerivativesTest, makeRefs)
{
  const Real va = 1, vb = 2, vc = 1.5;
  const auto [a, b, c] = makeRefs&lt;30&gt;(va, vb, vc);

  // matching order
  EXPECT_EQ(&amp;va, &amp;a());
  EXPECT_EQ(&amp;vb, &amp;b());
  EXPECT_EQ(&amp;vc, &amp;c());

  // correct tags
  EXPECT_EQ(a.D&lt;30&gt;()(), 1);
  EXPECT_EQ(a.D&lt;31&gt;()(), 0);
  EXPECT_EQ(a.D&lt;32&gt;()(), 0);

  EXPECT_EQ(b.D&lt;30&gt;()(), 0);
  EXPECT_EQ(b.D&lt;31&gt;()(), 1);
  EXPECT_EQ(b.D&lt;32&gt;()(), 0);

  EXPECT_EQ(c.D&lt;30&gt;()(), 0);
  EXPECT_EQ(c.D&lt;31&gt;()(), 0);
  EXPECT_EQ(c.D&lt;32&gt;()(), 1);
}

TEST(CompileTimeDerivativesTest, makeStandardDeviation)
{
  // start tag for the fitting parameters
  const int params = 30;

  // fitting parameter data and corresponding CTD objects
  const Real va = 1, vb = 2, vc = 1.5;
  const auto [a, b, c] = makeRefs&lt;params&gt;(va, vb, vc);

  // function variable (omit tag, since we dont need to derive w.r.t. x)
  const Real vx = 0.5;
  const auto x = makeRef(vx);

  // function expression
  const auto f = a + b * x + c * x * x;

  // covariance matrix for the a,b,c parameters
  // clang-format off
  CTMatrix&lt;Real, 3, 3&gt; covariance(
    0.2,  0.01, 0.07,
    0.01, 0.4,  0.05,
    0.07, 0.05, 0.3);
  // clang-format on

  // Object that calculates the standard deviation of f
  const auto std_dev = makeStandardDeviation&lt;params&gt;(f, covariance);

  EXPECT_NEAR(std_dev(), 0.6133922073192649, 1e-15);
}

TEST(CompileTimeDerivativesTest, conditional)
{
  Real vx = 0.0;
  const auto x = makeRef(vx);

  const auto result = conditional(x &lt; 3, 2 * x, 5 * x);

  for (vx = 0.0; vx &lt; 6.0; vx += 0.31)
  {
    if (vx &lt; 3)
      EXPECT_EQ(result(), 2 * vx);
    else
      EXPECT_EQ(result(), 5 * vx);
  }
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#b31065f6-c673-4710-ab03-a8c60a5b3bb5">(moose/unit/src/CompileTimeDerivativesTest.C)</a></section></section><div class="moose-modal modal" id="b31065f6-c673-4710-ab03-a8c60a5b3bb5"><div class="modal-content"><h4>(moose/unit/src/CompileTimeDerivativesTest.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;gtest/gtest.h&quot;

// Moose includes
#include &quot;MooseTypes.h&quot;
#include &quot;CompileTimeDerivatives.h&quot;

using namespace CompileTimeDerivatives;

TEST(CompileTimeDerivativesTest, simple)
{
  // this test serves as a simple example for the compile time derivative system

  // a variable to be used in the expression evaluation
  Real my_x = 1.0;

  // use an enum to use symbols for tags
  enum
  {
    dx
  };

  // we wrap this variable in a reference node that we tag with the `dx` enum
  const auto x = makeRef&lt;dx&gt;(my_x);

  // now we build an expression that uses our variable x
  // the expression is not yet evaluated
  const auto result = (x + 2) * (x + 3);

  // when evaluated this expression should always return (1+2)*(1*3) = 12
  // we evaluate the result using the () operator
  EXPECT_NEAR(result(), 12, 1e-10);

  // we can build the derivative using the D&lt;&gt;() function. The template parameter
  // is the tag we want to take the derivative w.r.t.
  const auto dx_result = result.D&lt;dx&gt;();

  // the derivative of the above expression is 1*(x+3)+(x+2)*1 = 2x+5
  // let&#x27;s set our original variable to 2
  my_x = 2.0;

  // if we re-evaluate the original expression we should get an updated result
  // of (2+2)*(2*3) = 20
  EXPECT_NEAR(result(), 20, 1e-10);

  // and for the derivative we expect 2*2+5 = 9
  EXPECT_NEAR(dx_result(), 9, 1e-10);
}

#define CTD_EVALTEST(expression, v0, v1, dv)                                                       \
  for (Real v = v0; v &lt;= v1; v += dv)                                                              \
  {                                                                                                \
    Real r1, r2;                                                                                   \
    {                                                                                              \
      const auto x = makeRef&lt;1&gt;(v);                                                                \
      const auto result = expression;                                                              \
      r1 = result();                                                                               \
    }                                                                                              \
    {                                                                                              \
      const auto &amp; x = v;                                                                          \
      r2 = expression;                                                                             \
    }                                                                                              \
    EXPECT_NEAR(r1, r2, 1e-13);                                                                    \
  }

TEST(CompileTimeDerivativesTest, evaluate)
{
  CTD_EVALTEST(x, -10, 10, 0.72)
  CTD_EVALTEST(2 * x, -10, 10, 0.72)
  CTD_EVALTEST(2.0 * x, -10, 10, 0.72)
  CTD_EVALTEST(x * 3, -10, 10, 0.72)
  CTD_EVALTEST(x * -3.0, -10, 10, 0.72)
  CTD_EVALTEST(x + 1, -10, 10, 0.72)
  CTD_EVALTEST(x - 1.0, -10, 10, 0.72)
  CTD_EVALTEST(0.5 + x, -10, 10, 0.72)
  CTD_EVALTEST(0.75 - x, -10, 10, 0.72)
  CTD_EVALTEST(1.0 / x, -10, 10, 0.72)
  CTD_EVALTEST(x / 2.0, -10, 10, 0.72)
  CTD_EVALTEST(x + (2.0 / x), -10, 10, 0.72)
  CTD_EVALTEST(x * (1.0 + x), -10, 10, 0.72)

  CTD_EVALTEST(x * (1.0 + x * (3.0 - x * (2.0 + x * (5.0 - x)))), -10, 10, 0.63)

  CTD_EVALTEST(x * -1.0 &gt; x * -2.0, -10, 10, 0.63)
  CTD_EVALTEST(x * -1.0 &lt; x * -2.0, -10, 10, 0.63)
  CTD_EVALTEST(x * -1.0 &gt;= x * -2.0, -10, 10, 1)
  CTD_EVALTEST(x * -1.0 &lt;= x * -2.0, -10, 10, 1)
  CTD_EVALTEST(0.0 &lt; x, -1, 1, 1)
  CTD_EVALTEST(0.0 &gt; x, -1, 1, 1)
  CTD_EVALTEST(0.0 &lt;= x, -1, 1, 1)
  CTD_EVALTEST(0.0 &gt;= x, -1, 1, 1)
  CTD_EVALTEST(0.0 == x, -1, 1, 1)
  CTD_EVALTEST(0.0 != x, -1, 1, 1)

  using namespace std;
  CTD_EVALTEST(sin(x), -10, 10, 0.72)
  CTD_EVALTEST(cos(x), -10, 10, 0.72)
  CTD_EVALTEST(tan(x), -10, 10, 0.72)
  CTD_EVALTEST(exp(x), -2, 2, 0.1)
  CTD_EVALTEST(erf(x), -2, 2, 0.1)
  CTD_EVALTEST(log(x), 0.1, 10, 0.1)
  CTD_EVALTEST(tanh(x), -10, 10, 0.1)
  CTD_EVALTEST(sinh(x), -4, 4, 0.1)
  CTD_EVALTEST(cosh(x), -4, 4, 0.1)
  CTD_EVALTEST(atan(x), -4, 4, 0.1)

  CTD_EVALTEST(min(x, x * x), -2, 2, 0.271)
  CTD_EVALTEST(max(x, x * x), -2, 2, 0.271)

  const auto v = makeValue(0.5);
  const auto r1 = CompileTimeDerivatives::atan2(1.0, 2.0);
  const auto r2 = CompileTimeDerivatives::atan2(v, 2.0);
  const auto r3 = CompileTimeDerivatives::atan2(1.0, v);
  const auto r4 = CompileTimeDerivatives::atan2(v, v);
  EXPECT_NEAR(r1(), 0.46364760900080609, 1e-12);
  EXPECT_NEAR(r2(), 0.24497866312686414, 1e-12);
  EXPECT_NEAR(r3(), 1.1071487177940904, 1e-12);
  EXPECT_NEAR(r4(), 0.7853981633974482, 1e-12);
}

TEST(CompileTimeDerivativesTest, finitedifference)
{
  Real v = 0;
  const auto x = makeRef&lt;1&gt;(v);

  const auto test = [&amp;v](auto expr, Real v0, Real v1, Real dv, Real eps = 1e-6, Real err = 1e-6)
  {
    for (Real vv = v0; vv &lt;= v1; vv += dv)
    {
      v = vv;
      const auto df = expr.template D&lt;1&gt;()();
      v = vv - eps;
      const auto f0 = expr();
      v = vv + eps;
      const auto f1 = expr();
      const auto fd = (f1 - f0) / (2.0 * eps);
      EXPECT_NEAR(df, fd, err);
    }
  };

  test(x, -3, 3, 0.21);
  test(-x, -3, 3, 0.21);
  test(x * x, -3, 3, 0.21);
  test(pow(x, 3), -3, 3, 0.21);
  test(pow(5, x), -3, 3, 0.21);
  test(pow(x, 3.0), -3, 3, 0.21);
  test(pow(5.0, x), -3, 3, 0.21);
  test(pow(x, x), 0.1, 3, 0.21);
  test(pow&lt;4&gt;(x), -3, 3, 0.21);
  test(pow&lt;4&gt;(2), -1, 1, 0.4);
  test(sin(x), -3, 3, 0.21);
  test(-sin(x), -3, 3, 0.21);
  test(cos(x), -3, 3, 0.21);
  test(tan(x), -10, 10, 0.2, 1e-7);
  test(exp(x), -2, 2, 0.2);
  test(erf(x), -2, 2, 0.2);
  test(log(x), 0.1, 3, 0.1);
  test(tanh(x), -10, 10, 0.2, 1e-7);
  test(sinh(x), -4, 4, 0.2);
  test(cosh(x), -4, 4, 0.2);
  test(atan(x), -4, 4, 0.2);
  test(atan2(x, 1), -3, 3, 0.21);
  test(atan2(1, x), -3, 3, 0.21);
  test(atan2(sin(x), cos(x)), -3, 3, 0.2);
}

TEST(CompileTimeDerivativesTest, derivative)
{
  enum
  {
    dX
  };

  Real v = 0.0;
  const auto x = makeRef&lt;dX&gt;(v);
  const auto result = x * (1.0 - x) - (x * log(x) + (1.0 - x) * log(1.0 - x));

  Real r0 = 0, r1 = 0, r2 = 0;
  for (v = 0.01; v &lt;= 0.99; v += 0.01)
  {
    r0 += std::abs(result() - (v * (1.0 - v) - (v * std::log(v) + (1.0 - v) * std::log(1.0 - v))));
    r1 += std::abs(result.D&lt;dX&gt;()() -
                   (-2.0 * v - std::log(v) + std::log(1.0 - v) - (v - 1.0) / (1.0 - v)));
    r2 += std::abs(result.D&lt;dX&gt;().D&lt;dX&gt;()() - (-2.0 + 1.0 / (v - 1.0) - 1.0 / v));
  }
  EXPECT_NEAR(r0, 0, 1e-12);
  EXPECT_NEAR(r1, 0, 1e-12);
  EXPECT_NEAR(r2, 0, 1e-12);
}

TEST(CompileTimeDerivativesTest, variable_reference)
{
  enum
  {
    dX
  };

  Real x = 0.0;
  const auto X = makeRef&lt;dX&gt;(x);
  const auto result = X * X + 100.0;

  x = 5;
  EXPECT_EQ(result(), 125.0);
  EXPECT_EQ(result.D&lt;dX&gt;()(), 10.0);

  x = 3;
  EXPECT_EQ(result(), 109.0);
  EXPECT_EQ(result.D&lt;dX&gt;()(), 6.0);
}

TEST(CompileTimeDerivativesTest, vector_reference)
{
  enum
  {
    dX
  };

  std::vector&lt;double&gt; _prop{1, 2, 3, 4};
  std::size_t _qp = 0;

  const auto prop = makeRef&lt;dX&gt;(_prop, _qp);
  const auto result = 3.0 * prop * prop;

  _qp = 1;
  EXPECT_EQ(result(), 12.0);
  EXPECT_EQ(result.D&lt;dX&gt;()(), 12.0);
  EXPECT_EQ(result.D&lt;dX&gt;().D&lt;dX&gt;()(), 6.0);

  _qp = 3;
  EXPECT_EQ(result(), 48.0);
  EXPECT_EQ(result.D&lt;dX&gt;()(), 24.0);
  EXPECT_EQ(result.D&lt;dX&gt;().D&lt;dX&gt;()(), 6.0);
}

TEST(CompileTimeDerivativesTest, print)
{
  std::vector&lt;double&gt; _prop{1, 2, 3, 4};
  std::size_t _qp = 2;
  const auto prop = makeRef(_prop, _qp);
  const auto result1 = 3.0 * prop * prop;
  EXPECT_EQ(result1.print(), &quot;3*[a[2]]*[a[2]]&quot;);

  Real v = 0.0;
  const auto x = makeRef(v);
  const auto result2 = x * (1.0 - x) - (x * log(x) + (1.0 - x) * log(1.0 - x));
  EXPECT_EQ(result2.print(), &quot;[v]*(1-[v])-([v]*log([v])+(1-[v])*log(1-[v]))&quot;);
}

TEST(CompileTimeDerivativesTest, makeRefs)
{
  const Real va = 1, vb = 2, vc = 1.5;
  const auto [a, b, c] = makeRefs&lt;30&gt;(va, vb, vc);

  // matching order
  EXPECT_EQ(&amp;va, &amp;a());
  EXPECT_EQ(&amp;vb, &amp;b());
  EXPECT_EQ(&amp;vc, &amp;c());

  // correct tags
  EXPECT_EQ(a.D&lt;30&gt;()(), 1);
  EXPECT_EQ(a.D&lt;31&gt;()(), 0);
  EXPECT_EQ(a.D&lt;32&gt;()(), 0);

  EXPECT_EQ(b.D&lt;30&gt;()(), 0);
  EXPECT_EQ(b.D&lt;31&gt;()(), 1);
  EXPECT_EQ(b.D&lt;32&gt;()(), 0);

  EXPECT_EQ(c.D&lt;30&gt;()(), 0);
  EXPECT_EQ(c.D&lt;31&gt;()(), 0);
  EXPECT_EQ(c.D&lt;32&gt;()(), 1);
}

TEST(CompileTimeDerivativesTest, makeStandardDeviation)
{
  // start tag for the fitting parameters
  const int params = 30;

  // fitting parameter data and corresponding CTD objects
  const Real va = 1, vb = 2, vc = 1.5;
  const auto [a, b, c] = makeRefs&lt;params&gt;(va, vb, vc);

  // function variable (omit tag, since we dont need to derive w.r.t. x)
  const Real vx = 0.5;
  const auto x = makeRef(vx);

  // function expression
  const auto f = a + b * x + c * x * x;

  // covariance matrix for the a,b,c parameters
  // clang-format off
  CTMatrix&lt;Real, 3, 3&gt; covariance(
    0.2,  0.01, 0.07,
    0.01, 0.4,  0.05,
    0.07, 0.05, 0.3);
  // clang-format on

  // Object that calculates the standard deviation of f
  const auto std_dev = makeStandardDeviation&lt;params&gt;(f, covariance);

  EXPECT_NEAR(std_dev(), 0.6133922073192649, 1e-15);
}

TEST(CompileTimeDerivativesTest, conditional)
{
  Real vx = 0.0;
  const auto x = makeRef(vx);

  const auto result = conditional(x &lt; 3, 2 * x, 5 * x);

  for (vx = 0.0; vx &lt; 6.0; vx += 0.31)
  {
    if (vx &lt; 3)
      EXPECT_EQ(result(), 2 * vx);
    else
      EXPECT_EQ(result(), 5 * vx);
  }
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#b9322005-eec8-4a1b-b2e6-13bfe5b8ffc7" class="tooltipped" data-position="left" data-tooltip="Uses">Uses</a></li><li><a href="#431567aa-1e7c-4a25-9072-3f1d12b32fa2" class="tooltipped" data-position="left" data-tooltip="Examples">Examples</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>