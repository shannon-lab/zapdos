<!DOCTYPE html><head><meta charset="UTF-8"><title>FillBetweenPointVectorsTools Namespace | Zapdos</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/zapdos.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Zapdos</a><a href="https://github.com/shannon-lab/zapdos" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="543b26df-303d-4b54-ac2e-c9a2b09a165d" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="df674fc3-a5e8-4927-b869-6436e1e94b48" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="ea6a3cf6-6a2a-4cc7-821f-3dd31c7b4f5a" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#" class="sidenav-trigger" data-target="3999fb6c-9af9-4b53-8d9c-4a027610fc01"><i class="material-icons">menu</i></a><ul class="sidenav" id="3999fb6c-9af9-4b53-8d9c-4a027610fc01"><li><a href="#!" class="dropdown-trigger" data-target="e12d93bb-4db3-41ad-9ac8-fd6a1daf48eb" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="8723a59d-ea05-4fa5-81ac-959f720c8b23" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="92b757fe-a024-4f36-bcac-4c0bc8550b3d" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="543b26df-303d-4b54-ac2e-c9a2b09a165d"><li><a href="../../getting_started/installation.html">Installation</a></li><li><a href="../../getting_started/using_zapdos.html">Using Zapdos</a></li><li><a href="../../getting_started/zapdos_meshing.html">Generating Meshes</a></li><li><a href="../../tutorial/index.html">Tutorial Slides</a></li></ul><ul class="dropdown-content" id="df674fc3-a5e8-4927-b869-6436e1e94b48"><li><a href="../../syntax/zapdos_only.html">Zapdos Input Syntax</a></li><li><a href="../../syntax/index.html">Complete Code Syntax</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/libmesh/classes.html">libMesh Doxygen</a></li><li><a href="../../a-to-z.html">Zapdos A to Z Index</a></li><li><a href="../../examples/crane_examples.html">CRANE Examples</a></li><li><a href="../../development/contributing.html">Contributing Guidelines</a></li><li><a href="../../development/code_standards.html">Code Standards</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="ea6a3cf6-6a2a-4cc7-821f-3dd31c7b4f5a"><li><a href="https://github.com/shannon-lab/zapdos/discussions">Zapdos Discussions Forum</a></li><li><a href="../../development/zapdos_developer_info.html">Zapdos Developer Information</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussions Forum</a></li><li><a href="https://mooseframework.inl.gov/">MOOSE Homepage</a></li><li><a href="../../development/moose_developer_info.html">MOOSE Developer Information</a></li></ul><ul class="dropdown-content" id="e12d93bb-4db3-41ad-9ac8-fd6a1daf48eb"><li><a href="../../getting_started/installation.html">Installation</a></li><li><a href="../../getting_started/using_zapdos.html">Using Zapdos</a></li><li><a href="../../getting_started/zapdos_meshing.html">Generating Meshes</a></li><li><a href="../../tutorial/index.html">Tutorial Slides</a></li></ul><ul class="dropdown-content" id="8723a59d-ea05-4fa5-81ac-959f720c8b23"><li><a href="../../syntax/zapdos_only.html">Zapdos Input Syntax</a></li><li><a href="../../syntax/index.html">Complete Code Syntax</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/libmesh/classes.html">libMesh Doxygen</a></li><li><a href="../../a-to-z.html">Zapdos A to Z Index</a></li><li><a href="../../examples/crane_examples.html">CRANE Examples</a></li><li><a href="../../development/contributing.html">Contributing Guidelines</a></li><li><a href="../../development/code_standards.html">Code Standards</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="92b757fe-a024-4f36-bcac-4c0bc8550b3d"><li><a href="https://github.com/shannon-lab/zapdos/discussions">Zapdos Discussions Forum</a></li><li><a href="../../development/zapdos_developer_info.html">Zapdos Developer Information</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussions Forum</a></li><li><a href="https://mooseframework.inl.gov/">MOOSE Homepage</a></li><li><a href="../../development/moose_developer_info.html">MOOSE Developer Information</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">utils</span><a href="#" class="breadcrumb">FillBetweenPointVectorsTools</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="710c44e8-5888-4656-8819-0a41bfd67d2b" data-section-level="1" data-section-text="FillBetweenPointVectorsTools Namespace"><h1 id="fillbetweenpointvectorstools-namespace">FillBetweenPointVectorsTools Namespace</h1><p><code>FillBetweenPointVectorsTools</code> contains tools that can be used to generate a triangular element transition layer mesh to connect two given curves (i.e., vectors of points) in the XY plane. It was originally developed for <code>PeripheralModifyGenerator</code> of the <code>Reactor</code> module. As these tools may also be useful for other applications, they are made available in this namespace. In this document, the algorithm of the tools are described.</p><section class="scrollspy" id="8f38c31c-ef97-490a-b596-bc4f6fadafc7" data-section-level="2" data-section-text="Fundamentals"><h2 id="fundamentals">Fundamentals</h2><p>This tool set was designed to create a mesh for a transition layer. A transition layer accommodates the shape and node placement of two pre-existing boundaries and fills the gap between them with elements. The most important input data needed to generate a transition layer is the node positions of the two boundaries. The generated mesh conforms to these two boundaries and connects the end nodes of each boundary using a straight line, as indicated in <a href="FillBetweenPointVectorsTools.html#transition">Figure 1</a>.</p><div class="card moose-float" style="display: block;margin-left:auto;margin-right:auto;width:50%;" id="transition"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../large_media/framework/utils/transition_layer.png" alt="A schematic drawing showing the fundamental functionality of the `FillBetweenPointVectorsTools`"></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 1: </span><span class="moose-caption-text" id="transition">A schematic drawing showing the fundamental functionality of the <code>FillBetweenPointVectorsTools</code></span></p></div></div></section><section class="scrollspy" id="2fb029d8-873d-4d8d-9552-6118a2671cc4" data-section-level="2" data-section-text="Single - Layer Transition Layer Meshing"><h2 id="single-layer-transition-layer-meshing">Single-Layer Transition Layer Meshing</h2><p>The most straightforward solution is to create a single layer of triangular elements as the transition layer. A triangular element is created by selecting three vertices from the two sets of boundary nodes. One node is selected from one of the two pre-existing boundaries and two nodes are selected from the other boundary. The selection of the nodes should minimize the length of sides connecting the two boundaries. This algorithm is illustrated in <a href="FillBetweenPointVectorsTools.html#single_layer">Figure 2</a>.</p><div class="card moose-float" style="display: block;margin-left:auto;margin-right:auto;width:50%;" id="single_layer"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../large_media/framework/utils/single_layer.png" alt="A schematic drawing showing the principle of single-layer transition layer meshing algorithm."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 2: </span><span class="moose-caption-text" id="single_layer">A schematic drawing showing the principle of single-layer transition layer meshing algorithm.</span></p></div></div><p>Starting from the first nodes of the two given boundaries, the first side is trivially created by connecting the first nodes of the two boundaries. Then, the two possible options of the next side of the triangle are examined, and the shorter length segment between the two boundaries is selected. This kind of selection is repeated until reaching the other side of the two boundaries.</p></section><section class="scrollspy" id="b8be0d2f-4fbc-4b4e-8419-e2c8a0faaab4" data-section-level="2" data-section-text="Multi - Layer Transition Layer Meshing"><h2 id="multi-layer-transition-layer-meshing">Multi-Layer Transition Layer Meshing</h2><p>In many cases, more than one layer of triangular elements is desired to improve mesh quality. The generation of a transition layer containing multiple sublayers can be done by repeating the single-layer transition layer meshing steps once the nodes of the intermediate sublayers are generated. Thus, the key procedure here is to create those intermediate nodes based on the two given vectors of nodes on the input boundaries. Here, the algorithm to generate the nodes for each sublayer is described from the simplest case to the most generalized scenario.</p><section id="5da406f0-1ba5-43a1-b1a9-7c05dd758234" data-section-level="3" data-section-text="Surrogate Node Interpolation Algorithm"><h3 id="surrogate-node-interpolation-algorithm">Surrogate Node Interpolation Algorithm</h3><p>Surrogate node interpolation algorithm is the most fundamental method used in this tool set for intermediate node generation. For simplicity, assume a case where all the nodes on each boundary are uniformly distributed. (Namely, the distance between neighboring nodes within a boundary is equal.) Assume that the two boundaries have <span class="moose-katex-inline-equation" id="moose-equation-9f2513c8-996c-4f56-aeb8-088de3d38b7f"><script>var element = document.getElementById("moose-equation-9f2513c8-996c-4f56-aeb8-088de3d38b7f");katex.render("M", element, {displayMode:false,throwOnError:false});</script></span> nodes (Side 1) and <span class="moose-katex-inline-equation" id="moose-equation-8c2e14cc-f2f2-4f75-b364-0effac730b68"><script>var element = document.getElementById("moose-equation-8c2e14cc-f2f2-4f75-b364-0effac730b68");katex.render("N", element, {displayMode:false,throwOnError:false});</script></span> nodes (Side 2), respectively, and that there are <span class="moose-katex-inline-equation" id="moose-equation-f49c60ba-6ffd-4329-b269-9a8299c52fce"><script>var element = document.getElementById("moose-equation-f49c60ba-6ffd-4329-b269-9a8299c52fce");katex.render("K", element, {displayMode:false,throwOnError:false});</script></span> sublayers of elements in between. From Side 1 to Side 2, using arithmetic progression, the <span class="moose-katex-inline-equation" id="moose-equation-848f00da-851b-4575-9510-3f5e28415572"><script>var element = document.getElementById("moose-equation-848f00da-851b-4575-9510-3f5e28415572");katex.render("k", element, {displayMode:false,throwOnError:false});</script></span>th layer of intermediate nodes have <span class="moose-katex-inline-equation" id="moose-equation-a4be0151-deb4-4d62-9950-db9ee71bc72c"><script>var element = document.getElementById("moose-equation-a4be0151-deb4-4d62-9950-db9ee71bc72c");katex.render("S=\\lceil M+k(N-M)/K \\rfloor", element, {displayMode:false,throwOnError:false});</script></span> nodes. To get the positions of these nodes, surrogate nodes are first calculated on the two input boundaries using interpolation leveraging MOOSE&#x27;s <a class="moose-source-filename tooltipped modal-trigger" href="#82874519-da47-47a3-8b8e-3ff62988c9a0"><code>LinearInterpolation</code></a> utility.</p><pre style="max-height:350px;"><code class="language-cpp">
#pragma once

#include &quot;Moose.h&quot;
#include &quot;MooseTypes.h&quot;

#include &lt;vector&gt;
#include &lt;string&gt;

/**
 * This class interpolates values given a set of data pairs and an abscissa.
 */
class LinearInterpolation
{
public:
  /* Constructor, Takes two vectors of points for which to apply the fit.  One should be of the
   * independent variable while the other should be of the dependent variable.  These values should
   * correspond to one and other in the same position.
   */
  LinearInterpolation(const std::vector&lt;Real&gt; &amp; X,
                      const std::vector&lt;Real&gt; &amp; Y,
                      const bool extrap = false);
  LinearInterpolation() : _x(std::vector&lt;Real&gt;()), _y(std::vector&lt;Real&gt;()), _extrap(false) {}

  virtual ~LinearInterpolation() = default;

  /**
   * Set the x and y values.
   */
  void setData(const std::vector&lt;Real&gt; &amp; X, const std::vector&lt;Real&gt; &amp; Y)
  {
    _x = X;
    _y = Y;
    errorCheck();
  }

  void errorCheck();

  /**
   * This function will take an independent variable input and will return the dependent variable
   * based on the generated fit
   */
  template &lt;typename T&gt;
  T sample(const T &amp; x) const;

  /**
   * This function will take an independent variable input and will return the derivative of the
   * dependent variable
   * with respect to the independent variable based on the generated fit
   */
  template &lt;typename T&gt;
  T sampleDerivative(const T &amp; x) const;

  /**
   * This function returns the size of the array holding the points, i.e. the number of sample
   * points
   */
  unsigned int getSampleSize() const;

  /**
   * This function returns the integral of the function over the whole domain
   */
  Real integrate();

  /**
   * Returns the integral of the function over a specified domain
   *
   * @param[in] x1  First point in integral domain
   * @param[in] x2  Second point in integral domain
   */
  Real integratePartial(Real x1, Real x2) const;

  Real domain(int i) const;
  Real range(int i) const;

private:
  std::vector&lt;Real&gt; _x;
  std::vector&lt;Real&gt; _y;

  bool _extrap;
};

// for backwards compatibility
typedef LinearInterpolation ADLinearInterpolation;

// temporary fixes to avoid breaking bison
template &lt;typename T&gt;
class LinearInterpolationTempl : public LinearInterpolation
{
public:
  using LinearInterpolation::LinearInterpolation;
};
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#311e683c-4e7d-4de7-9abd-8231b543694d">(moose/framework/include/utils/LinearInterpolation.h)</a><p>Here, take Side 1 as an example. As mentioned above, Side 1 has <span class="moose-katex-inline-equation" id="moose-equation-ee2f48c8-a4db-426f-a17b-ff1cd7788fad"><script>var element = document.getElementById("moose-equation-ee2f48c8-a4db-426f-a17b-ff1cd7788fad");katex.render("M", element, {displayMode:false,throwOnError:false});</script></span> nodes, the coordinates of which are <span class="moose-katex-inline-equation" id="moose-equation-c35189f7-61ce-467e-bcce-3dd06c31b127"><script>var element = document.getElementById("moose-equation-c35189f7-61ce-467e-bcce-3dd06c31b127");katex.render("(x_0,y_0,z_0)", element, {displayMode:false,throwOnError:false});</script></span>, <span class="moose-katex-inline-equation" id="moose-equation-1c09073f-ca50-4a13-b83e-49502a09f9c7"><script>var element = document.getElementById("moose-equation-1c09073f-ca50-4a13-b83e-49502a09f9c7");katex.render("(x_1,y_1,z_1)", element, {displayMode:false,throwOnError:false});</script></span>, ..., <span class="moose-katex-inline-equation" id="moose-equation-935ca628-fbab-49ba-aa5e-4bbf612ed700"><script>var element = document.getElementById("moose-equation-935ca628-fbab-49ba-aa5e-4bbf612ed700");katex.render("(x_{M-1},y_{M-1},z_{M-1})", element, {displayMode:false,throwOnError:false});</script></span>. To get interpolated coordinates of the nodes on Side 1, the coordinate parameters <span class="moose-katex-inline-equation" id="moose-equation-8f9db148-412c-4b16-8a0f-8b426183ea37"><script>var element = document.getElementById("moose-equation-8f9db148-412c-4b16-8a0f-8b426183ea37");katex.render("\\{x_i\\}", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-3a84f61c-1141-425e-b50a-fe2dc0efaf0d"><script>var element = document.getElementById("moose-equation-3a84f61c-1141-425e-b50a-fe2dc0efaf0d");katex.render("\\{y_i\\}", element, {displayMode:false,throwOnError:false});</script></span> will be the dependent variables of interpolation (i.e., <span class="moose-katex-inline-equation" id="moose-equation-c7acb47c-98b1-4be5-8b8e-aaf3fda04cfa"><script>var element = document.getElementById("moose-equation-c7acb47c-98b1-4be5-8b8e-aaf3fda04cfa");katex.render("Y", element, {displayMode:false,throwOnError:false});</script></span> in the <a class="moose-source-filename tooltipped modal-trigger" href="#62f94502-780c-48c1-8c52-50b208b6758a"><code>LinearInterpolation</code></a> of MOOSE), while the <span class="moose-katex-inline-equation" id="moose-equation-631eb0c5-e85d-470a-956f-2f87b05d9a2e"><script>var element = document.getElementById("moose-equation-631eb0c5-e85d-470a-956f-2f87b05d9a2e");katex.render("X", element, {displayMode:false,throwOnError:false});</script></span> was set as {<span class="moose-katex-inline-equation" id="moose-equation-dacdb448-9e9f-445c-88f9-5c177a9e1b55"><script>var element = document.getElementById("moose-equation-dacdb448-9e9f-445c-88f9-5c177a9e1b55");katex.render("0", element, {displayMode:false,throwOnError:false});</script></span>, <span class="moose-katex-inline-equation" id="moose-equation-c6f7ca83-c684-4b70-abd5-3004e2898e6b"><script>var element = document.getElementById("moose-equation-c6f7ca83-c684-4b70-abd5-3004e2898e6b");katex.render("1/(M-1)", element, {displayMode:false,throwOnError:false});</script></span>, <span class="moose-katex-inline-equation" id="moose-equation-026b42e5-f20a-4c68-bfff-04ec56927362"><script>var element = document.getElementById("moose-equation-026b42e5-f20a-4c68-bfff-04ec56927362");katex.render("2/(M-1)", element, {displayMode:false,throwOnError:false});</script></span>,...,<span class="moose-katex-inline-equation" id="moose-equation-2ebeaa62-2b19-436b-a65f-440c977435a5"><script>var element = document.getElementById("moose-equation-2ebeaa62-2b19-436b-a65f-440c977435a5");katex.render("(M-2)/(M-1)", element, {displayMode:false,throwOnError:false});</script></span>, <span class="moose-katex-inline-equation" id="moose-equation-6ad06f64-22bc-47e0-95b6-bbb60076bd03"><script>var element = document.getElementById("moose-equation-6ad06f64-22bc-47e0-95b6-bbb60076bd03");katex.render("1", element, {displayMode:false,throwOnError:false});</script></span>} (equal intervals). Note that <span class="moose-katex-inline-equation" id="moose-equation-8d5ae946-ef8e-4f64-85a3-cab4caf85616"><script>var element = document.getElementById("moose-equation-8d5ae946-ef8e-4f64-85a3-cab4caf85616");katex.render("\\{z_i\\}", element, {displayMode:false,throwOnError:false});</script></span> does not need interpolation as we are working in the XY plane. For an intermediate layer with <span class="moose-katex-inline-equation" id="moose-equation-f6759c4c-fcbe-4336-a664-c570507392eb"><script>var element = document.getElementById("moose-equation-f6759c4c-fcbe-4336-a664-c570507392eb");katex.render("S", element, {displayMode:false,throwOnError:false});</script></span>, <span class="moose-katex-inline-equation" id="moose-equation-cfcd6998-3d94-4f66-9a33-7cc7bb92b26e"><script>var element = document.getElementById("moose-equation-cfcd6998-3d94-4f66-9a33-7cc7bb92b26e");katex.render("S", element, {displayMode:false,throwOnError:false});</script></span> surrogate nodes are created on Side 1 using the aforementioned interpolation data and the following <span class="moose-katex-inline-equation" id="moose-equation-c4633c0c-5568-4461-b0f9-90d16fae1ab6"><script>var element = document.getElementById("moose-equation-c4633c0c-5568-4461-b0f9-90d16fae1ab6");katex.render("X", element, {displayMode:false,throwOnError:false});</script></span> values {<span class="moose-katex-inline-equation" id="moose-equation-93cbc00e-f743-4a4f-8a5d-15f68dead7e4"><script>var element = document.getElementById("moose-equation-93cbc00e-f743-4a4f-8a5d-15f68dead7e4");katex.render("0", element, {displayMode:false,throwOnError:false});</script></span>, <span class="moose-katex-inline-equation" id="moose-equation-220cef2f-9c4c-4011-bd07-63ca2d3e0153"><script>var element = document.getElementById("moose-equation-220cef2f-9c4c-4011-bd07-63ca2d3e0153");katex.render("1/(S-1)", element, {displayMode:false,throwOnError:false});</script></span>, <span class="moose-katex-inline-equation" id="moose-equation-fa26c821-86ba-46d7-8532-02d56b507e27"><script>var element = document.getElementById("moose-equation-fa26c821-86ba-46d7-8532-02d56b507e27");katex.render("2/(S-1)", element, {displayMode:false,throwOnError:false});</script></span>,...,<span class="moose-katex-inline-equation" id="moose-equation-fa83a71b-3be0-4503-9d91-78a91cc2a2b1"><script>var element = document.getElementById("moose-equation-fa83a71b-3be0-4503-9d91-78a91cc2a2b1");katex.render("(S-2)/(S-1)", element, {displayMode:false,throwOnError:false});</script></span>, <span class="moose-katex-inline-equation" id="moose-equation-cb41d30a-ea57-454e-ac9a-26f2cf3643cd"><script>var element = document.getElementById("moose-equation-cb41d30a-ea57-454e-ac9a-26f2cf3643cd");katex.render("1", element, {displayMode:false,throwOnError:false});</script></span>}. Meanwhile, another <span class="moose-katex-inline-equation" id="moose-equation-820b8ece-c392-4497-8190-b107a26a46f5"><script>var element = document.getElementById("moose-equation-820b8ece-c392-4497-8190-b107a26a46f5");katex.render("S", element, {displayMode:false,throwOnError:false});</script></span> surrogate nodes are created on Side 2 using a similar approach. Finally, the positions of the <span class="moose-katex-inline-equation" id="moose-equation-8aaaa957-fa06-44df-b6aa-d82446c0efa9"><script>var element = document.getElementById("moose-equation-8aaaa957-fa06-44df-b6aa-d82446c0efa9");katex.render("S", element, {displayMode:false,throwOnError:false});</script></span> intermediate nodes can be calculated by further interpolating the surrogate nodes created on the two boundaries. In <a href="FillBetweenPointVectorsTools.html#multi_layer_uniform">Figure 3</a>, an example of applying surrogate node interpolation algorithm to a boundary with 9 uniformly distributed nodes and a boundary with 4 uniformly distributed nodes to generate an intermediate node layer with six nodes is illustrated.</p><div class="card moose-float" style="display: block;margin-left:auto;margin-right:auto;width:50%;" id="multi_layer_uniform"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../large_media/framework/utils/multi_layer_uniform.png" alt="A schematic drawing showing an example of surrogate node interpolation algorithm. Blue and green nodes belong to the original boundaries; yellow nodes are surrogate nodes generated by linear interpolation on the two original boundaries; and orange nodes are the produced intermediate layer nodes calculated by interpolating the surrogate nodes on the two boundaries."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 3: </span><span class="moose-caption-text" id="multi_layer_uniform">A schematic drawing showing an example of surrogate node interpolation algorithm. Blue and green nodes belong to the original boundaries; yellow nodes are surrogate nodes generated by linear interpolation on the two original boundaries; and orange nodes are the produced intermediate layer nodes calculated by interpolating the surrogate nodes on the two boundaries.</span></p></div></div></section><section id="82c9626a-4758-4c0e-9ddf-b1a1ef699f08" data-section-level="3" data-section-text="Weighted Surrogate Nodes"><h3 id="weighted-surrogate-nodes">Weighted Surrogate Nodes</h3><p>A more general scenario is that the nodes on the two original boundaries are not uniformly distributed. In that case, weights need to be used during the linear interpolation for surrogate node generation. Again, given a boundary (Side 1) with <span class="moose-katex-inline-equation" id="moose-equation-772342e9-3fca-46e8-a036-8346b892e8a1"><script>var element = document.getElementById("moose-equation-772342e9-3fca-46e8-a036-8346b892e8a1");katex.render("M", element, {displayMode:false,throwOnError:false});</script></span> nodes, {<span class="moose-katex-inline-equation" id="moose-equation-d14b21c3-9932-4ddc-958f-2e83e081a15b"><script>var element = document.getElementById("moose-equation-d14b21c3-9932-4ddc-958f-2e83e081a15b");katex.render("^1p_0", element, {displayMode:false,throwOnError:false});</script></span>, <span class="moose-katex-inline-equation" id="moose-equation-fe9883d3-b825-497d-92da-8b71ca892f15"><script>var element = document.getElementById("moose-equation-fe9883d3-b825-497d-92da-8b71ca892f15");katex.render("^1p_1", element, {displayMode:false,throwOnError:false});</script></span>,...,<span class="moose-katex-inline-equation" id="moose-equation-882bf4c2-acd8-4819-9167-f8ff25f1cf94"><script>var element = document.getElementById("moose-equation-882bf4c2-acd8-4819-9167-f8ff25f1cf94");katex.render("^1p_{M-2}", element, {displayMode:false,throwOnError:false});</script></span>, <span class="moose-katex-inline-equation" id="moose-equation-93f09acf-63bc-43fc-bc5c-f4d8588db32c"><script>var element = document.getElementById("moose-equation-93f09acf-63bc-43fc-bc5c-f4d8588db32c");katex.render("^1p_{M-1}", element, {displayMode:false,throwOnError:false});</script></span>}, the distance between the neighboring nodes are {<span class="moose-katex-inline-equation" id="moose-equation-bdfe71f4-e5ef-45f4-8ba7-1809a9f91321"><script>var element = document.getElementById("moose-equation-bdfe71f4-e5ef-45f4-8ba7-1809a9f91321");katex.render("^1l_1", element, {displayMode:false,throwOnError:false});</script></span>, <span class="moose-katex-inline-equation" id="moose-equation-0c57a145-bd9c-4edb-929e-6d243fc04311"><script>var element = document.getElementById("moose-equation-0c57a145-bd9c-4edb-929e-6d243fc04311");katex.render("^1l_2", element, {displayMode:false,throwOnError:false});</script></span>,...,<span class="moose-katex-inline-equation" id="moose-equation-afe2fbcd-3a35-4166-b626-39ac30e53d46"><script>var element = document.getElementById("moose-equation-afe2fbcd-3a35-4166-b626-39ac30e53d46");katex.render("^1l_{M-2}", element, {displayMode:false,throwOnError:false});</script></span>,<span class="moose-katex-inline-equation" id="moose-equation-b2b4acca-c483-4c80-aad5-929045b339d7"><script>var element = document.getElementById("moose-equation-b2b4acca-c483-4c80-aad5-929045b339d7");katex.render("^1l_{M-1}", element, {displayMode:false,throwOnError:false});</script></span>}. The total length of Side 1 is <span class="moose-katex-inline-equation" id="moose-equation-5714e8bd-78a7-43e9-9df2-46e4e890dbc6"><script>var element = document.getElementById("moose-equation-5714e8bd-78a7-43e9-9df2-46e4e890dbc6");katex.render("L=\\Sigma_{i=1}^{M-1}{l_i}", element, {displayMode:false,throwOnError:false});</script></span>. This boundary can be mapped to a boundary with uniformly distributed nodes. For the new boundary, each segment has a weight <span class="moose-katex-inline-equation" id="moose-equation-3404cfa8-5d4f-4d03-a461-d50361aace49"><script>var element = document.getElementById("moose-equation-3404cfa8-5d4f-4d03-a461-d50361aace49");katex.render("^1w_i=(M-1)l_i/L", element, {displayMode:false,throwOnError:false});</script></span>. Surrogated nodes can then be generated on the new boundary using the same approach as mentioned in the previous subsection. After that, using the weights calculated before, the surrogate nodes are derived to weighted surrogate nodes. After repeating these steps on Side 2, the intermediate nodes can be generated. These procedures are visualized in <a href="FillBetweenPointVectorsTools.html#weighted_surrogate">Figure 4</a>.</p><div class="card moose-float" style="display: block;margin-left:auto;margin-right:auto;width:80%;" id="weighted_surrogate"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../large_media/framework/utils/weighted_surrogate.png" alt="A schematic drawing showing an example of weighted surrogate node interpolation algorithm used for intermediate nodes generation when non-uniform distributed nodes are involved on the two original boundaries."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 4: </span><span class="moose-caption-text" id="weighted_surrogate">A schematic drawing showing an example of weighted surrogate node interpolation algorithm used for intermediate nodes generation when non-uniform distributed nodes are involved on the two original boundaries.</span></p></div></div></section><section id="f1f2096f-180d-4c81-89ac-21ed476cb951" data-section-level="3" data-section-text="Quadrilateral Element Transition Layer in a Special Case"><h3 id="quadrilateral-element-transition-layer-in-a-special-case">Quadrilateral Element Transition Layer in a Special Case</h3><p><code>FillBetweenPointVectorsTools</code> is generally designed for meshing with triangular elements because of their flexibility in accommodating complex node distribution. However, if Side 1 and Side 2 boundaries have the same number of nodes, then the transition layer can be meshed using quadrilateral elements straightforwardly. <code>FillBetweenPointVectorsTools</code> is equipped with this special quadrilateral meshing capability.</p></section></section><section class="scrollspy" id="813ec245-d2fa-475e-8b74-5060422e13dc" data-section-level="2" data-section-text="Applications"><h2 id="applications">Applications</h2><p>In <code>FillBetweenPointVectorsTools</code>, the transition layer generation functionality is provided as a method shown as follows:</p><pre style="max-height:350px;"><code class="language-cpp">
#pragma once
#include &quot;LinearInterpolation.h&quot;
#include &quot;SplineInterpolation.h&quot;
#include &quot;MooseException.h&quot;
#include &quot;libmesh/mesh_base.h&quot;
#include &quot;libmesh/mesh_modification.h&quot;

namespace FillBetweenPointVectorsTools
{
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#9b620303-5a49-4410-886f-ca4556653a81">(moose/framework/include/utils/FillBetweenPointVectorsTools.h)</a><p>Here, <code>mesh</code> is a reference <code>ReplicatedMesh</code> to contain the generated transition layer mesh; <code>boundary_points_vec_1</code> and <code>boundary_points_vec_2</code> are vectors of nodes for Side 1 and Side 2 boundaries; <code>num_layers</code> is the number of element sublayers; <code>transition_layer_id</code> is the subdomain ID of the generated transition layer elements; <code>input_boundary_1_id</code> and <code>input_boundary_2_id</code> are the IDs of the boundaries of the generated transition layer mesh corresponding to the input Sides 1 and 2, respectively; <code>begin_side_boundary_id</code> and <code>end_side_boundary_id</code> are the IDs of the other two boundaries of the generated transition layer mesh that connect the starting and ending points of the two input Sides; and <code>type</code> and <code>name</code> are the class type and object name of the mesh generator calling this method for error message generation purpose. If <code>boundary_points_vec_1</code> and <code>boundary_points_vec_2</code> have the same size, <code>quad_elem</code> can be set as <code>true</code> so that quadrilateral elements instead of triangular elements are used to construct the transition layer mesh. In addition, <code>bias_parameter</code> can be used to control the meshing biasing of the element sublayers. By default, a non-biased sublayer meshing (i.e., equally spaced) is selected by setting <code>bias_parameter</code> as 1.0. Any positive <code>bias_parameter</code> is used as the manually set biasing factor, while a zero or negative <code>bias_parameter</code> activates automatic biasing, where the local node density values on the two input boundaries are used to determine the local biasing factor. If automatic biasing is selected, <code>sigma</code> is used as the Gaussian parameter to perform Gaussian blurring to smoothen the local node density to enhance robustness of the algorithm.</p><div class="card moose-float" style="display: block;margin-left:auto;margin-right:auto;width:80%;" id="examples"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../large_media/framework/utils/transition_layer_tools_examples.png" alt="Some representative meshes generated by `FillBetweenPointVectorsTools`: (left) a transition layer mesh defined by two oppositely oriented arcs; (middle) a transition layer mesh defined by one arc and a complex curve; (right) a half-circle mesh."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 5: </span><span class="moose-caption-text" id="examples">Some representative meshes generated by <code>FillBetweenPointVectorsTools</code>: (left) a transition layer mesh defined by two oppositely oriented arcs; (middle) a transition layer mesh defined by one arc and a complex curve; (right) a half-circle mesh.</span></p></div></div><p>One application of this tool is to generate a mesh with two curves and two straight lines as its external boundaries. As shown in <a href="FillBetweenPointVectorsTools.html#examples">Figure 5</a>, a series of simple and complex shapes can be meshed. Users can leverage <a href="../meshgenerators/FillBetweenPointVectorsGenerator.html"><code>FillBetweenPointVectorsGenerator</code></a> and <a href="../meshgenerators/FillBetweenSidesetsGenerator.html"><code>FillBetweenSidesetsGenerator</code></a> as testing tools. </p></section></section><div class="moose-modal modal" id="82874519-da47-47a3-8b8e-3ff62988c9a0"><div class="modal-content"><h4>(moose/framework/src/utils/LinearInterpolation.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;LinearInterpolation.h&quot;
#include &quot;MooseUtils.h&quot;

#include &quot;ChainedReal.h&quot;

#include &lt;cassert&gt;
#include &lt;fstream&gt;
#include &lt;stdexcept&gt;

LinearInterpolation::LinearInterpolation(const std::vector&lt;Real&gt; &amp; x,
                                         const std::vector&lt;Real&gt; &amp; y,
                                         const bool extrap)
  : _x(x), _y(y), _extrap(extrap)
{
  errorCheck();
}

void
LinearInterpolation::errorCheck()
{
  if (_x.size() != _y.size())
    throw std::domain_error(&quot;Vectors are not the same length&quot;);

  for (unsigned int i = 0; i + 1 &lt; _x.size(); ++i)
    if (_x[i] &gt;= _x[i + 1])
    {
      std::ostringstream oss;
      oss &lt;&lt; &quot;x-values are not strictly increasing: x[&quot; &lt;&lt; i &lt;&lt; &quot;]: &quot; &lt;&lt; _x[i] &lt;&lt; &quot; x[&quot; &lt;&lt; i + 1
          &lt;&lt; &quot;]: &quot; &lt;&lt; _x[i + 1];
      throw std::domain_error(oss.str());
    }
}

template &lt;typename T&gt;
T
LinearInterpolation::sample(const T &amp; x) const
{
  // this is a hard error
  if (_x.empty())
    mooseError(&quot;Trying to evaluate an empty LinearInterpolation&quot;);

  // special case for single function nodes
  if (_x.size() == 1)
    return _y[0];

  // endpoint cases
  if (_extrap)
  {
    if (x &lt; _x[0])
      return _y[0] + (x - _x[0]) / (_x[1] - _x[0]) * (_y[1] - _y[0]);
    if (x &gt;= _x.back())
      return _y.back() +
             (x - _x.back()) / (_x[_x.size() - 2] - _x.back()) * (_y[_y.size() - 2] - _y.back());
  }
  else
  {
    if (x &lt; _x[0])
      return _y[0];
    if (x &gt;= _x.back())
      return _y.back();
  }

  auto upper = std::upper_bound(_x.begin(), _x.end(), x);
  const auto i = cast_int&lt;std::size_t&gt;(std::distance(_x.begin(), upper) - 1);
  if (i == cast_int&lt;std::size_t&gt;(_x.size() - 1))
    // std::upper_bound returns the end() iterator if there are no elements that are
    // an upper bound to the value. Since x &gt;= _x.back() has already returned above,
    // this means x is a NaN, so we return a NaN here.
    return std::nan(&quot;&quot;);
  else
    return _y[i] + (_y[i + 1] - _y[i]) * (x - _x[i]) / (_x[i + 1] - _x[i]);
}

template Real LinearInterpolation::sample&lt;Real&gt;(const Real &amp;) const;
template ADReal LinearInterpolation::sample&lt;ADReal&gt;(const ADReal &amp;) const;
template ChainedReal LinearInterpolation::sample&lt;ChainedReal&gt;(const ChainedReal &amp;) const;

template &lt;typename T&gt;
T
LinearInterpolation::sampleDerivative(const T &amp; x) const
{
  // endpoint cases
  if (_extrap)
  {
    if (x &lt;= _x[0])
      return (_y[1] - _y[0]) / (_x[1] - _x[0]);
    if (x &gt;= _x.back())
      return (_y[_y.size() - 2] - _y.back()) / (_x[_x.size() - 2] - _x.back());
  }
  else
  {
    if (x &lt; _x[0])
      return 0.0;
    if (x &gt;= _x.back())
      return 0.0;
  }

  auto upper = std::upper_bound(_x.begin(), _x.end(), x);
  const auto i = cast_int&lt;std::size_t&gt;(std::distance(_x.begin(), upper) - 1);
  if (i == cast_int&lt;std::size_t&gt;(_x.size() - 1))
    // std::upper_bound returns the end() iterator if there are no elements that are
    // an upper bound to the value. Since x &gt;= _x.back() has already returned above,
    // this means x is a NaN, so we return a NaN here.
    return std::nan(&quot;&quot;);
  else
    return (_y[i + 1] - _y[i]) / (_x[i + 1] - _x[i]);
}

template Real LinearInterpolation::sampleDerivative&lt;Real&gt;(const Real &amp;) const;
template ADReal LinearInterpolation::sampleDerivative&lt;ADReal&gt;(const ADReal &amp;) const;
template ChainedReal LinearInterpolation::sampleDerivative&lt;ChainedReal&gt;(const ChainedReal &amp;) const;

Real
LinearInterpolation::integrate()
{
  Real answer = 0;
  for (unsigned int i = 1; i &lt; _x.size(); ++i)
    answer += 0.5 * (_y[i] + _y[i - 1]) * (_x[i] - _x[i - 1]);

  return answer;
}

Real
LinearInterpolation::integratePartial(Real xA, Real xB) const
{
  // integral computation below will assume that x2 &gt; x1; if this is not the
  // case, compute as if it is and then use identity to convert
  Real x1, x2;
  bool switch_bounds;
  if (MooseUtils::absoluteFuzzyEqual(xA, xB))
    return 0.0;
  else if (xB &gt; xA)
  {
    x1 = xA;
    x2 = xB;
    switch_bounds = false;
  }
  else
  {
    x1 = xB;
    x2 = xA;
    switch_bounds = true;
  }

  // compute integral with knowledge that x2 &gt; x1
  Real integral = 0.0;
  // find minimum i : x[i] &gt; x; if x &gt; x[n-1], i = n
  auto n = _x.size();
  const unsigned int i1 =
      x1 &lt;= _x[n - 1] ? std::distance(_x.begin(), std::upper_bound(_x.begin(), _x.end(), x1)) : n;
  const unsigned int i2 =
      x2 &lt;= _x[n - 1] ? std::distance(_x.begin(), std::upper_bound(_x.begin(), _x.end(), x2)) : n;
  unsigned int i = i1;
  while (i &lt;= i2)
  {
    if (i == 0)
    {
      // note i1 = i
      Real integral1, integral2;
      if (_extrap)
      {
        const Real dydx = (_y[1] - _y[0]) / (_x[1] - _x[0]);
        const Real y1 = _y[0] + dydx * (x1 - _x[0]);
        integral1 = 0.5 * (y1 + _y[0]) * (_x[0] - x1);
        if (i2 == i)
        {
          const Real y2 = _y[0] + dydx * (x2 - _x[0]);
          integral2 = 0.5 * (y2 + _y[0]) * (_x[0] - x2);
        }
        else
          integral2 = 0.0;
      }
      else
      {
        integral1 = _y[0] * (_x[0] - x1);
        if (i2 == i)
          integral2 = _y[0] * (_x[0] - x2);
        else
          integral2 = 0.0;
      }

      integral += integral1 - integral2;
    }
    else if (i == n)
    {
      // note i2 = i
      Real integral1, integral2;
      if (_extrap)
      {
        const Real dydx = (_y[n - 1] - _y[n - 2]) / (_x[n - 1] - _x[n - 2]);
        const Real y2 = _y[n - 1] + dydx * (x2 - _x[n - 1]);
        integral2 = 0.5 * (y2 + _y[n - 1]) * (x2 - _x[n - 1]);
        if (i1 == n)
        {
          const Real y1 = _y[n - 1] + dydx * (x1 - _x[n - 1]);
          integral1 = 0.5 * (y1 + _y[n - 1]) * (x1 - _x[n - 1]);
        }
        else
          integral1 = 0.0;
      }
      else
      {
        integral2 = _y[n - 1] * (x2 - _x[n - 1]);
        if (i1 == n)
          integral1 = _y[n - 1] * (x1 - _x[n - 1]);
        else
          integral1 = 0.0;
      }

      integral += integral2 - integral1;
    }
    else
    {
      Real integral1;
      if (i == i1)
      {
        const Real dydx = (_y[i] - _y[i - 1]) / (_x[i] - _x[i - 1]);
        const Real y1 = _y[i - 1] + dydx * (x1 - _x[i - 1]);
        integral1 = 0.5 * (y1 + _y[i - 1]) * (x1 - _x[i - 1]);
      }
      else
        integral1 = 0.0;

      Real integral2;
      if (i == i2)
      {
        const Real dydx = (_y[i] - _y[i - 1]) / (_x[i] - _x[i - 1]);
        const Real y2 = _y[i - 1] + dydx * (x2 - _x[i - 1]);
        integral2 = 0.5 * (y2 + _y[i - 1]) * (x2 - _x[i - 1]);
      }
      else
        integral2 = 0.5 * (_y[i] + _y[i - 1]) * (_x[i] - _x[i - 1]);

      integral += integral2 - integral1;
    }

    i++;
  }

  // apply identity if bounds were switched
  if (switch_bounds)
    return -1.0 * integral;
  else
    return integral;
}

Real
LinearInterpolation::domain(int i) const
{
  return _x[i];
}

Real
LinearInterpolation::range(int i) const
{
  return _y[i];
}

unsigned int
LinearInterpolation::getSampleSize() const
{
  return _x.size();
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="311e683c-4e7d-4de7-9abd-8231b543694d"><div class="modal-content"><h4>(moose/framework/include/utils/LinearInterpolation.h)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;Moose.h&quot;
#include &quot;MooseTypes.h&quot;

#include &lt;vector&gt;
#include &lt;string&gt;

/**
 * This class interpolates values given a set of data pairs and an abscissa.
 */
class LinearInterpolation
{
public:
  /* Constructor, Takes two vectors of points for which to apply the fit.  One should be of the
   * independent variable while the other should be of the dependent variable.  These values should
   * correspond to one and other in the same position.
   */
  LinearInterpolation(const std::vector&lt;Real&gt; &amp; X,
                      const std::vector&lt;Real&gt; &amp; Y,
                      const bool extrap = false);
  LinearInterpolation() : _x(std::vector&lt;Real&gt;()), _y(std::vector&lt;Real&gt;()), _extrap(false) {}

  virtual ~LinearInterpolation() = default;

  /**
   * Set the x and y values.
   */
  void setData(const std::vector&lt;Real&gt; &amp; X, const std::vector&lt;Real&gt; &amp; Y)
  {
    _x = X;
    _y = Y;
    errorCheck();
  }

  void errorCheck();

  /**
   * This function will take an independent variable input and will return the dependent variable
   * based on the generated fit
   */
  template &lt;typename T&gt;
  T sample(const T &amp; x) const;

  /**
   * This function will take an independent variable input and will return the derivative of the
   * dependent variable
   * with respect to the independent variable based on the generated fit
   */
  template &lt;typename T&gt;
  T sampleDerivative(const T &amp; x) const;

  /**
   * This function returns the size of the array holding the points, i.e. the number of sample
   * points
   */
  unsigned int getSampleSize() const;

  /**
   * This function returns the integral of the function over the whole domain
   */
  Real integrate();

  /**
   * Returns the integral of the function over a specified domain
   *
   * @param[in] x1  First point in integral domain
   * @param[in] x2  Second point in integral domain
   */
  Real integratePartial(Real x1, Real x2) const;

  Real domain(int i) const;
  Real range(int i) const;

private:
  std::vector&lt;Real&gt; _x;
  std::vector&lt;Real&gt; _y;

  bool _extrap;
};

// for backwards compatibility
typedef LinearInterpolation ADLinearInterpolation;

// temporary fixes to avoid breaking bison
template &lt;typename T&gt;
class LinearInterpolationTempl : public LinearInterpolation
{
public:
  using LinearInterpolation::LinearInterpolation;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="62f94502-780c-48c1-8c52-50b208b6758a"><div class="modal-content"><h4>(moose/framework/src/utils/LinearInterpolation.C)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;LinearInterpolation.h&quot;
#include &quot;MooseUtils.h&quot;

#include &quot;ChainedReal.h&quot;

#include &lt;cassert&gt;
#include &lt;fstream&gt;
#include &lt;stdexcept&gt;

LinearInterpolation::LinearInterpolation(const std::vector&lt;Real&gt; &amp; x,
                                         const std::vector&lt;Real&gt; &amp; y,
                                         const bool extrap)
  : _x(x), _y(y), _extrap(extrap)
{
  errorCheck();
}

void
LinearInterpolation::errorCheck()
{
  if (_x.size() != _y.size())
    throw std::domain_error(&quot;Vectors are not the same length&quot;);

  for (unsigned int i = 0; i + 1 &lt; _x.size(); ++i)
    if (_x[i] &gt;= _x[i + 1])
    {
      std::ostringstream oss;
      oss &lt;&lt; &quot;x-values are not strictly increasing: x[&quot; &lt;&lt; i &lt;&lt; &quot;]: &quot; &lt;&lt; _x[i] &lt;&lt; &quot; x[&quot; &lt;&lt; i + 1
          &lt;&lt; &quot;]: &quot; &lt;&lt; _x[i + 1];
      throw std::domain_error(oss.str());
    }
}

template &lt;typename T&gt;
T
LinearInterpolation::sample(const T &amp; x) const
{
  // this is a hard error
  if (_x.empty())
    mooseError(&quot;Trying to evaluate an empty LinearInterpolation&quot;);

  // special case for single function nodes
  if (_x.size() == 1)
    return _y[0];

  // endpoint cases
  if (_extrap)
  {
    if (x &lt; _x[0])
      return _y[0] + (x - _x[0]) / (_x[1] - _x[0]) * (_y[1] - _y[0]);
    if (x &gt;= _x.back())
      return _y.back() +
             (x - _x.back()) / (_x[_x.size() - 2] - _x.back()) * (_y[_y.size() - 2] - _y.back());
  }
  else
  {
    if (x &lt; _x[0])
      return _y[0];
    if (x &gt;= _x.back())
      return _y.back();
  }

  auto upper = std::upper_bound(_x.begin(), _x.end(), x);
  const auto i = cast_int&lt;std::size_t&gt;(std::distance(_x.begin(), upper) - 1);
  if (i == cast_int&lt;std::size_t&gt;(_x.size() - 1))
    // std::upper_bound returns the end() iterator if there are no elements that are
    // an upper bound to the value. Since x &gt;= _x.back() has already returned above,
    // this means x is a NaN, so we return a NaN here.
    return std::nan(&quot;&quot;);
  else
    return _y[i] + (_y[i + 1] - _y[i]) * (x - _x[i]) / (_x[i + 1] - _x[i]);
}

template Real LinearInterpolation::sample&lt;Real&gt;(const Real &amp;) const;
template ADReal LinearInterpolation::sample&lt;ADReal&gt;(const ADReal &amp;) const;
template ChainedReal LinearInterpolation::sample&lt;ChainedReal&gt;(const ChainedReal &amp;) const;

template &lt;typename T&gt;
T
LinearInterpolation::sampleDerivative(const T &amp; x) const
{
  // endpoint cases
  if (_extrap)
  {
    if (x &lt;= _x[0])
      return (_y[1] - _y[0]) / (_x[1] - _x[0]);
    if (x &gt;= _x.back())
      return (_y[_y.size() - 2] - _y.back()) / (_x[_x.size() - 2] - _x.back());
  }
  else
  {
    if (x &lt; _x[0])
      return 0.0;
    if (x &gt;= _x.back())
      return 0.0;
  }

  auto upper = std::upper_bound(_x.begin(), _x.end(), x);
  const auto i = cast_int&lt;std::size_t&gt;(std::distance(_x.begin(), upper) - 1);
  if (i == cast_int&lt;std::size_t&gt;(_x.size() - 1))
    // std::upper_bound returns the end() iterator if there are no elements that are
    // an upper bound to the value. Since x &gt;= _x.back() has already returned above,
    // this means x is a NaN, so we return a NaN here.
    return std::nan(&quot;&quot;);
  else
    return (_y[i + 1] - _y[i]) / (_x[i + 1] - _x[i]);
}

template Real LinearInterpolation::sampleDerivative&lt;Real&gt;(const Real &amp;) const;
template ADReal LinearInterpolation::sampleDerivative&lt;ADReal&gt;(const ADReal &amp;) const;
template ChainedReal LinearInterpolation::sampleDerivative&lt;ChainedReal&gt;(const ChainedReal &amp;) const;

Real
LinearInterpolation::integrate()
{
  Real answer = 0;
  for (unsigned int i = 1; i &lt; _x.size(); ++i)
    answer += 0.5 * (_y[i] + _y[i - 1]) * (_x[i] - _x[i - 1]);

  return answer;
}

Real
LinearInterpolation::integratePartial(Real xA, Real xB) const
{
  // integral computation below will assume that x2 &gt; x1; if this is not the
  // case, compute as if it is and then use identity to convert
  Real x1, x2;
  bool switch_bounds;
  if (MooseUtils::absoluteFuzzyEqual(xA, xB))
    return 0.0;
  else if (xB &gt; xA)
  {
    x1 = xA;
    x2 = xB;
    switch_bounds = false;
  }
  else
  {
    x1 = xB;
    x2 = xA;
    switch_bounds = true;
  }

  // compute integral with knowledge that x2 &gt; x1
  Real integral = 0.0;
  // find minimum i : x[i] &gt; x; if x &gt; x[n-1], i = n
  auto n = _x.size();
  const unsigned int i1 =
      x1 &lt;= _x[n - 1] ? std::distance(_x.begin(), std::upper_bound(_x.begin(), _x.end(), x1)) : n;
  const unsigned int i2 =
      x2 &lt;= _x[n - 1] ? std::distance(_x.begin(), std::upper_bound(_x.begin(), _x.end(), x2)) : n;
  unsigned int i = i1;
  while (i &lt;= i2)
  {
    if (i == 0)
    {
      // note i1 = i
      Real integral1, integral2;
      if (_extrap)
      {
        const Real dydx = (_y[1] - _y[0]) / (_x[1] - _x[0]);
        const Real y1 = _y[0] + dydx * (x1 - _x[0]);
        integral1 = 0.5 * (y1 + _y[0]) * (_x[0] - x1);
        if (i2 == i)
        {
          const Real y2 = _y[0] + dydx * (x2 - _x[0]);
          integral2 = 0.5 * (y2 + _y[0]) * (_x[0] - x2);
        }
        else
          integral2 = 0.0;
      }
      else
      {
        integral1 = _y[0] * (_x[0] - x1);
        if (i2 == i)
          integral2 = _y[0] * (_x[0] - x2);
        else
          integral2 = 0.0;
      }

      integral += integral1 - integral2;
    }
    else if (i == n)
    {
      // note i2 = i
      Real integral1, integral2;
      if (_extrap)
      {
        const Real dydx = (_y[n - 1] - _y[n - 2]) / (_x[n - 1] - _x[n - 2]);
        const Real y2 = _y[n - 1] + dydx * (x2 - _x[n - 1]);
        integral2 = 0.5 * (y2 + _y[n - 1]) * (x2 - _x[n - 1]);
        if (i1 == n)
        {
          const Real y1 = _y[n - 1] + dydx * (x1 - _x[n - 1]);
          integral1 = 0.5 * (y1 + _y[n - 1]) * (x1 - _x[n - 1]);
        }
        else
          integral1 = 0.0;
      }
      else
      {
        integral2 = _y[n - 1] * (x2 - _x[n - 1]);
        if (i1 == n)
          integral1 = _y[n - 1] * (x1 - _x[n - 1]);
        else
          integral1 = 0.0;
      }

      integral += integral2 - integral1;
    }
    else
    {
      Real integral1;
      if (i == i1)
      {
        const Real dydx = (_y[i] - _y[i - 1]) / (_x[i] - _x[i - 1]);
        const Real y1 = _y[i - 1] + dydx * (x1 - _x[i - 1]);
        integral1 = 0.5 * (y1 + _y[i - 1]) * (x1 - _x[i - 1]);
      }
      else
        integral1 = 0.0;

      Real integral2;
      if (i == i2)
      {
        const Real dydx = (_y[i] - _y[i - 1]) / (_x[i] - _x[i - 1]);
        const Real y2 = _y[i - 1] + dydx * (x2 - _x[i - 1]);
        integral2 = 0.5 * (y2 + _y[i - 1]) * (x2 - _x[i - 1]);
      }
      else
        integral2 = 0.5 * (_y[i] + _y[i - 1]) * (_x[i] - _x[i - 1]);

      integral += integral2 - integral1;
    }

    i++;
  }

  // apply identity if bounds were switched
  if (switch_bounds)
    return -1.0 * integral;
  else
    return integral;
}

Real
LinearInterpolation::domain(int i) const
{
  return _x[i];
}

Real
LinearInterpolation::range(int i) const
{
  return _y[i];
}

unsigned int
LinearInterpolation::getSampleSize() const
{
  return _x.size();
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="9b620303-5a49-4410-886f-ca4556653a81"><div class="modal-content"><h4>(moose/framework/include/utils/FillBetweenPointVectorsTools.h)</h4><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://mooseframework.inl.gov
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once
#include &quot;LinearInterpolation.h&quot;
#include &quot;SplineInterpolation.h&quot;
#include &quot;MooseException.h&quot;
#include &quot;libmesh/mesh_base.h&quot;
#include &quot;libmesh/mesh_modification.h&quot;

namespace FillBetweenPointVectorsTools
{
/**
 * Generates a 2D mesh with triangular elements for a region defined by two curves (sets of Points)
 * @param mesh a reference MeshBase to contain the generated mesh
 * @param boundary_points_vec_1 vector of Points of Side #1
 * @param boundary_points_vec_2 vector of Points of Side #2
 * @param num_layers number of sublayers of elements
 * @param transition_layer_id subdomain id of the generated mesh
 * @param input_boundary_1_id id of the generated mesh&#x27;s external boundary that originates from
 * boundary_points_vec_1
 * @param input_boundary_2_id id of the generated mesh&#x27;s external boundary that originates from
 * boundary_points_vec_2
 * @param begin_side_boundary_id id of the generated mesh&#x27;s external boundary that connects the
 * first Points of the two input Point vectors
 * @param end_side_boundary_id id of the generated mesh&#x27;s external boundary that connects the last
 * Points of the two input Point vectors
 * @param type type of the MOOSE object that calls this method for error messages
 * @param name name of the MOOSE object that calls this method for error messages
 * @param quad_elem whether the QUAD4 elements are used to construct the mesh
 * @param bias_parameter a parameter to control bias options (1) &gt;0, biasing factor (2) &lt;=0
 * automatic biasing
 * @param sigma Gaussian parameter used for Gaussian blurring of local node density; only used if
 * bias_parameter &lt;= 0
 */
void fillBetweenPointVectorsGenerator(MeshBase &amp; mesh,
                                      const std::vector&lt;Point&gt; &amp; boundary_points_vec_1,
                                      const std::vector&lt;Point&gt; &amp; boundary_points_vec_2,
                                      const unsigned int num_layers,
                                      const subdomain_id_type transition_layer_id,
                                      const boundary_id_type input_boundary_1_id,
                                      const boundary_id_type input_boundary_2_id,
                                      const boundary_id_type begin_side_boundary_id,
                                      const boundary_id_type end_side_boundary_id,
                                      const std::string type,
                                      const std::string name,
                                      const bool quad_elem = false,
                                      const Real bias_parameter = 1.0,
                                      const Real sigma = 3.0);

/**
 * Generates a 2D mesh with triangular elements for a region defined by two curves (sets of Points)
 * @param mesh a reference MeshBase to contain the generated mesh
 * @param boundary_points_vec_1 vector of Points of Side #1
 * @param boundary_points_vec_2 vector of Points of Side #2
 * @param num_layers number of sublayers of elements
 * @param transition_layer_id subdomain id of the generated mesh
 * @param external_boundary_id id of the generated mesh&#x27;s external boundary
 * @param type type of the MOOSE object that calls this method
 * @param name name of the MOOSE object that calls this method
 * @param quad_elem whether the QUAD4 elements are used to construct the mesh
 */
void fillBetweenPointVectorsGenerator(MeshBase &amp; mesh,
                                      const std::vector&lt;Point&gt; &amp; boundary_points_vec_1,
                                      const std::vector&lt;Point&gt; &amp; boundary_points_vec_2,
                                      const unsigned int num_layers,
                                      const subdomain_id_type transition_layer_id,
                                      const boundary_id_type external_boundary_id,
                                      const std::string type,
                                      const std::string name,
                                      const bool quad_elem = false);

/**
 * Generates a 2D mesh based on a 2D vector of Nodes using QUAD4 elements in the xy-plane
 * @param mesh a reference MeshBase to contain the generated mesh
 * @param nodes a 2D vector of nodes based on which the mesh is built
 * @param num_layers number of sublayers of elements
 * @param node_number_vec number of nodes on each sublayer
 * @param transition_layer_id subdomain id of the generated mesh
 * @param input_boundary_1_id id of the generated mesh&#x27;s external boundary that originates from
 * boundary_points_vec_1
 * @param input_boundary_2_id id of the generated mesh&#x27;s external boundary that originates from
 * boundary_points_vec_2
 * @param begin_side_boundary_id id of the generated mesh&#x27;s external boundary that connects the
 * first Points of the two input Point vectors
 * @param end_side_boundary_id id of the generated mesh&#x27;s external boundary that connects the last
 * Points of the two input Point vectors
 */
void elementsCreationFromNodesVectorsQuad(MeshBase &amp; mesh,
                                          const std::vector&lt;std::vector&lt;Node *&gt;&gt; &amp; nodes,
                                          const unsigned int num_layers,
                                          const std::vector&lt;unsigned int&gt; &amp; node_number_vec,
                                          const subdomain_id_type transition_layer_id,
                                          const boundary_id_type input_boundary_1_id,
                                          const boundary_id_type input_boundary_2_id,
                                          const boundary_id_type begin_side_boundary_id,
                                          const boundary_id_type end_side_boundary_id);

/**
 * Generates a 2D mesh based on a 2D vector of Nodes using TRI3 elements in the xy-plane
 * @param mesh a reference MeshBase to contain the generated mesh
 * @param nodes a 2D vector of nodes based on which the mesh is built
 * @param num_layers number of sublayers of elements
 * @param node_number_vec number of nodes on each sublayer
 * @param transition_layer_id subdomain id of the generated mesh
 * @param input_boundary_1_id id of the generated mesh&#x27;s external boundary that originates from
 * boundary_points_vec_1
 * @param input_boundary_2_id id of the generated mesh&#x27;s external boundary that originates from
 * boundary_points_vec_2
 * @param begin_side_boundary_id id of the generated mesh&#x27;s external boundary that connects the
 * first Points of the two input Point vectors
 * @param end_side_boundary_id id of the generated mesh&#x27;s external boundary that connects the last
 * Points of the two input Point vectors
 */
void elementsCreationFromNodesVectors(MeshBase &amp; mesh,
                                      const std::vector&lt;std::vector&lt;Node *&gt;&gt; &amp; nodes,
                                      const unsigned int num_layers,
                                      const std::vector&lt;unsigned int&gt; &amp; node_number_vec,
                                      const subdomain_id_type transition_layer_id,
                                      const boundary_id_type input_boundary_1_id,
                                      const boundary_id_type input_boundary_2_id,
                                      const boundary_id_type begin_side_boundary_id,
                                      const boundary_id_type end_side_boundary_id);

/**
 * Generates weights, weighted indices and corresponding interpolation
 * @param vec_node_num number of points/nodes on the given curve
 * @param boundary_points_vec vector of points on the given curve
 * @param vec_index unweighted index vector
 * @param wt weights based on point-to-point distances
 * @param index weighted index vector
 * @param sigma Gaussian parameter used for Gaussian blurring of local node density
 * @param linear_vec_x linear interpolation of x coordinates based on weighted index
 * @param linear_vec_y linear interpolation of y coordinates based on weighted index
 * @param spline_vec_l spline interpolation of inter-node length based on weighted index
 */
void weightedInterpolator(const unsigned int vec_node_num,
                          const std::vector&lt;Point&gt; &amp; boundary_points_vec,
                          std::vector&lt;Real&gt; &amp; vec_index,
                          std::vector&lt;Real&gt; &amp; wt,
                          std::vector&lt;Real&gt; &amp; index,
                          const Real sigma,
                          std::unique_ptr&lt;LinearInterpolation&gt; &amp; linear_vec_x,
                          std::unique_ptr&lt;LinearInterpolation&gt; &amp; linear_vec_y,
                          std::unique_ptr&lt;SplineInterpolation&gt; &amp; spline_vec_l);

/**
 * Generates weighted surrogate index vectors on one side for points of a sublayer curve
 * @param weighted_surrogate_index weighted surrogate index vector
 * @param unweighted_surrogate_index unweighted surrogate index vector
 * @param node_number_vec number of points/nodes on the sublayer curve
 * @param index weighted index vector of the points on the side
 * @param wt weight vector of the points on the side
 * @param boundary_node_num number of points/nodes on the side
 * @param i index of the sublayer
 */
void surrogateGenerator(std::vector&lt;Real&gt; &amp; weighted_surrogate_index,
                        std::vector&lt;Real&gt; &amp; unweighted_surrogate_index,
                        const std::vector&lt;unsigned int&gt; &amp; node_number_vec,
                        const std::vector&lt;Real&gt; &amp; index,
                        const std::vector&lt;Real&gt; &amp; wt,
                        const unsigned int boundary_node_num,
                        const unsigned int i);

/**
 * Decide whether one of the input vector of Points needs to be flipped to ensure correct transition
 * layer shape
 * @param vec_pts_1 first vector of points to be examined
 * @param vec_pts_2 second vector of points to be examined
 * @return whether one of the vectors needs to be flipped to ensure correct transition layer shape
 */
bool needFlip(const std::vector&lt;Point&gt; &amp; vec_pts_1, const std::vector&lt;Point&gt; &amp; vec_pts_2);

/**
 * Decides whether a boundary of a given mesh is a closed loop with consecutive nodes&#x27;s azimuthal
 * angles change monotonically.
 * @param mesh input mesh that contains the boundary to be examined
 * @param max_node_radius the maximum radius of the nodes on the
 * boundary
 * @param boundary_ordered_node_list the ordered node ids on the given boundary
 * @param origin_pt origin position of the given mesh (used for azimuthal angle calculation)
 * @param bid ID of the boundary to be examined
 * @return whether the boundary is a closed loop with consecutive nodes&#x27;s azimuthal
 * angles change monotonically
 */
bool isBoundarySimpleClosedLoop(MeshBase &amp; mesh,
                                Real &amp; max_node_radius,
                                std::vector&lt;dof_id_type&gt; &amp; boundary_ordered_node_list,
                                const Point origin_pt,
                                const boundary_id_type bid);

/**
 * Decides whether a boundary of a given mesh is a closed loop with consecutive nodes&#x27;s azimuthal
 * angles change monotonically.
 * @param mesh input mesh that contains the boundary to be examined
 * @param max_node_radius the maximum radius of the nodes on the
 * boundary
 * @param origin_pt origin position of the given mesh (used for azimuthal angle calculation)
 * @param bid ID of the boundary to be examined
 * @return whether the boundary is a closed loop with consecutive nodes&#x27;s azimuthal
 * angles change monotonically
 */
bool isBoundarySimpleClosedLoop(MeshBase &amp; mesh,
                                Real &amp; max_node_radius,
                                const Point origin_pt,
                                const boundary_id_type bid);

/**
 * Decides whether a boundary of a given mesh is a closed loop with consecutive nodes&#x27;s azimuthal
 * angles change monotonically.
 * @param mesh input mesh that contains the boundary to be examined
 * @param origin_pt origin position of the given mesh (used for azimuthal angle calculation)
 * @param bid ID of the boundary to be examined
 * @return whether the boundary is a closed loop with consecutive nodes&#x27;s azimuthal
 * angles change monotonically
 */
bool isBoundarySimpleClosedLoop(MeshBase &amp; mesh, const Point origin_pt, const boundary_id_type bid);

/**
 * Decides whether a boundary of a given mesh is an open single-segment boundary.
 * @param mesh input mesh that contains the boundary to be examined
 * @param max_node_radius the maximum radius of the nodes on the
 * boundary
 * @param boundary_ordered_node_list the ordered node ids on the given boundary
 * @param origin_pt origin position of the given mesh (used for azimuthal angle calculation)
 * @param bid ID of the boundary to be examined
 * @return whether the boundary is an open single-segment boundary
 */
bool isBoundaryOpenSingleSegment(MeshBase &amp; mesh,
                                 Real &amp; max_node_radius,
                                 std::vector&lt;dof_id_type&gt; &amp; boundary_ordered_node_list,
                                 const Point origin_pt,
                                 const boundary_id_type bid);

/**
 * Decides whether a curve contained in a given mesh is a closed loop with consecutive nodes&#x27;s
 * azimuthal angles change monotonically.
 * @param mesh input mesh that contains the curve to be examined
 * @param max_node_radius the maximum radius of the nodes on the
 * curve
 * @param ordered_node_list the ordered node ids on the given curve
 * @param origin_pt origin position of the given mesh (used for azimuthal angle calculation)
 * @return whether the curve is a closed loop with consecutive nodes&#x27;s azimuthal
 * angles change monotonically
 */
bool isCurveSimpleClosedLoop(MeshBase &amp; mesh,
                             Real &amp; max_node_radius,
                             std::vector&lt;dof_id_type&gt; &amp; ordered_node_list,
                             const Point origin_pt);

/**
 * Decides whether a curve contained in a given mesh is a closed loop with consecutive nodes&#x27;s
 * azimuthal angles change monotonically.
 * @param mesh input mesh that contains the curve to be examined
 * @param max_node_radius the maximum radius of the nodes on the
 * curve
 * @param origin_pt origin position of the given mesh (used for azimuthal angle calculation)
 * @return whether the curve is a closed loop with consecutive nodes&#x27;s azimuthal
 * angles change monotonically
 */
bool isCurveSimpleClosedLoop(MeshBase &amp; mesh, Real &amp; max_node_radius, const Point origin_pt);

/**
 * Decides whether a curve contained in a given mesh is a closed loop with consecutive nodes&#x27;s
 * azimuthal angles change monotonically.
 * @param mesh input mesh that contains the curve to be examined
 * @param origin_pt origin position of the given mesh (used for azimuthal angle calculation)
 * @return whether the curve is a closed loop with consecutive nodes&#x27;s azimuthal
 * angles change monotonically
 */
bool isCurveSimpleClosedLoop(MeshBase &amp; mesh, const Point origin_pt);

/**
 * Decides whether a curve contained in a given mesh is an open single-segment curve.
 * @param mesh input mesh that contains the curve to be examined
 * @param max_node_radius the maximum radius of the nodes on the
 * curve
 * @param ordered_node_list the ordered node ids on the given curve
 * @param origin_pt origin position of the given mesh (used for azimuthal angle calculation)
 * @return whether the boundary is an open single-segment boundary
 */
bool isCurveOpenSingleSegment(MeshBase &amp; mesh,
                              Real &amp; max_node_radius,
                              std::vector&lt;dof_id_type&gt; &amp; ordered_node_list,
                              const Point origin_pt);

/**
 * Decides whether a series of nodes contained in a given mesh forms a closed loop with consecutive
 * nodes&#x27;s azimuthal angles change monotonically.
 * @param mesh input mesh that contains the node series to be examined
 * @param max_node_radius the maximum radius of the nodes in the series
 * @param ordered_node_list the ordered node ids on the given curve
 * @param node_assm the assembly of the node id pairs that correspond to vertices of the sides on
 * the closed loop
 * @param midpoint_node_list the node ids of the midpoints of the sides for quadratic sides
 * @param origin_pt origin position of the given mesh (used for azimuthal angle calculation)
 * @param is_closed_loop whether the series of nodes form a closed loop with consecutive nodes&#x27;s
 * azimuthal angles changing monotonically
 * @param suppress_exception whether to suppress the exceptions thrown by this function if the
 * boundary is not closed
 */
void isClosedLoop(MeshBase &amp; mesh,
                  Real &amp; max_node_radius,
                  std::vector&lt;dof_id_type&gt; &amp; ordered_node_list,
                  std::vector&lt;std::pair&lt;dof_id_type, dof_id_type&gt;&gt; &amp; node_assm,
                  std::vector&lt;dof_id_type&gt; &amp; midpoint_node_list,
                  const Point origin_pt,
                  const std::string input_type,
                  bool &amp; is_closed_loop,
                  const bool suppress_exception = false);

/**
 * Decides whether a series of nodes contained in a given mesh forms a closed loop with consecutive
 * nodes&#x27;s azimuthal angles change monotonically.
 * @param mesh input mesh that contains the node series to be examined
 * @param max_node_radius the maximum radius of the nodes in the series
 * @param ordered_node_list the ordered node ids on the given curve
 * @param node_assm the assembly of the node id pairs that correspond vertices of a series of sides
 * @param origin_pt origin position of the given mesh (used for azimuthal angle calculation)
 * @param is_closed_loop whether the series of nodes form a closed loop with consecutive nodes&#x27;s
 * azimuthal angles change monotonically
 * @param suppress_exception whether to suppress the exceptions thrown by this function if the
 * boundary is not closed
 */
void isClosedLoop(MeshBase &amp; mesh,
                  Real &amp; max_node_radius,
                  std::vector&lt;dof_id_type&gt; &amp; ordered_node_list,
                  std::vector&lt;std::pair&lt;dof_id_type, dof_id_type&gt;&gt; &amp; node_assm,
                  const Point origin_pt,
                  const std::string input_type,
                  bool &amp; is_closed_loop,
                  const bool suppress_exception = false);

/**
 * Decides whether a boundary of a given mesh is an external boundary.
 * @param mesh input mesh that contains the boundary to be examined
 * @param bid ID of the boundary to be examined
 * @return whether the boundary is the external boundary of the given mesh
 */
bool isExternalBoundary(MeshBase &amp; mesh, const boundary_id_type bid);

/**
 * Creates an QUAD4 element that can be extruded in (0 0 1) direction.
 * @param elem pointer of the element to be created
 * @param nd_0 pointer of element&#x27;s first node
 * @param nd_1 pointer of element&#x27;s second node
 * @param nd_2 pointer of element&#x27;s third node
 * @param nd_3 pointer of element&#x27;s fourth node
 * @param transition_layer_id id of the subdomain that this element belongs to
 * @return whether the element is flipped to ensure (0 0 1) extrudability
 */
bool buildQuadElement(Elem * elem,
                      Node * nd_0,
                      Node * nd_1,
                      Node * nd_2,
                      Node * nd_3,
                      const subdomain_id_type transition_layer_id);

/**
 * Creates an TRI3 element that can be extruded in (0 0 1) direction.
 * @param elem pointer of the element to be created
 * @param nd_0 pointer of element&#x27;s first node
 * @param nd_1 pointer of element&#x27;s second node
 * @param nd_2 pointer of element&#x27;s third node
 * @param transition_layer_id id of the subdomain that this element belongs to
 * @return whether the element is flipped to ensure (0 0 1) extrudability
 */
bool buildTriElement(Elem * elem,
                     Node * nd_0,
                     Node * nd_1,
                     Node * nd_2,
                     const subdomain_id_type transition_layer_id);
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#8f38c31c-ef97-490a-b596-bc4f6fadafc7" class="tooltipped" data-position="left" data-tooltip="Fundamentals">Fundamentals</a></li><li><a href="#2fb029d8-873d-4d8d-9552-6118a2671cc4" class="tooltipped" data-position="left" data-tooltip="Single - Layer Transition Layer Meshing">Single - Layer Transition Layer Meshing</a></li><li><a href="#b8be0d2f-4fbc-4b4e-8419-e2c8a0faaab4" class="tooltipped" data-position="left" data-tooltip="Multi - Layer Transition Layer Meshing">Multi - Layer Transition Layer Meshing</a></li><li><a href="#813ec245-d2fa-475e-8b74-5060422e13dc" class="tooltipped" data-position="left" data-tooltip="Applications">Applications</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>