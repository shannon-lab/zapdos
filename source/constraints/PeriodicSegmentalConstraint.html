<!DOCTYPE html><head><meta charset="UTF-8"><title>PeriodicSegmentalConstraint | Zapdos</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/zapdos.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Zapdos</a><a href="https://github.com/shannon-lab/zapdos" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="dec9c90b-e374-4193-b639-7f8b8e9f3536" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="11dff239-1105-42f7-87b9-4396bab458c5" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="c83d8057-fd0b-44e2-92c1-1d90e0566179" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#" class="sidenav-trigger" data-target="578388f4-f129-4ab5-8678-e3d95920a75c"><i class="material-icons">menu</i></a><ul class="sidenav" id="578388f4-f129-4ab5-8678-e3d95920a75c"><li><a href="#!" class="dropdown-trigger" data-target="b35a1ca2-c5cb-4f12-8501-34c9dd31133b" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="adab0ce9-1f6a-4323-9645-9605d0127421" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="73254eee-790e-4ddf-8295-0b3af01c1f9c" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="dec9c90b-e374-4193-b639-7f8b8e9f3536"><li><a href="../../getting_started/installation.html">Installation</a></li><li><a href="../../getting_started/using_zapdos.html">Using Zapdos</a></li><li><a href="../../getting_started/zapdos_meshing.html">Generating Meshes</a></li><li><a href="../../tutorial/index.html">Tutorial Slides</a></li></ul><ul class="dropdown-content" id="11dff239-1105-42f7-87b9-4396bab458c5"><li><a href="../../syntax/zapdos_only.html">Zapdos Input Syntax</a></li><li><a href="../../syntax/index.html">Complete Code Syntax</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/libmesh/classes.html">libMesh Doxygen</a></li><li><a href="../../a-to-z.html">Zapdos A to Z Index</a></li><li><a href="../../examples/crane_examples.html">CRANE Examples</a></li><li><a href="../../development/contributing.html">Contributing Guidelines</a></li><li><a href="../../development/code_standards.html">Code Standards</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="c83d8057-fd0b-44e2-92c1-1d90e0566179"><li><a href="https://github.com/shannon-lab/zapdos/discussions">Zapdos Discussions Forum</a></li><li><a href="../../development/zapdos_developer_info.html">Zapdos Developer Information</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussions Forum</a></li><li><a href="https://mooseframework.inl.gov/">MOOSE Homepage</a></li><li><a href="../../development/moose_developer_info.html">MOOSE Developer Information</a></li></ul><ul class="dropdown-content" id="b35a1ca2-c5cb-4f12-8501-34c9dd31133b"><li><a href="../../getting_started/installation.html">Installation</a></li><li><a href="../../getting_started/using_zapdos.html">Using Zapdos</a></li><li><a href="../../getting_started/zapdos_meshing.html">Generating Meshes</a></li><li><a href="../../tutorial/index.html">Tutorial Slides</a></li></ul><ul class="dropdown-content" id="adab0ce9-1f6a-4323-9645-9605d0127421"><li><a href="../../syntax/zapdos_only.html">Zapdos Input Syntax</a></li><li><a href="../../syntax/index.html">Complete Code Syntax</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/libmesh/classes.html">libMesh Doxygen</a></li><li><a href="../../a-to-z.html">Zapdos A to Z Index</a></li><li><a href="../../examples/crane_examples.html">CRANE Examples</a></li><li><a href="../../development/contributing.html">Contributing Guidelines</a></li><li><a href="../../development/code_standards.html">Code Standards</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="73254eee-790e-4ddf-8295-0b3af01c1f9c"><li><a href="https://github.com/shannon-lab/zapdos/discussions">Zapdos Discussions Forum</a></li><li><a href="../../development/zapdos_developer_info.html">Zapdos Developer Information</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussions Forum</a></li><li><a href="https://mooseframework.inl.gov/">MOOSE Homepage</a></li><li><a href="../../development/moose_developer_info.html">MOOSE Developer Information</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">constraints</span><a href="#" class="breadcrumb">PeriodicSegmentalConstraint</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="50eb876a-b8ca-465c-94e9-0e5855acd0a3" data-section-level="1" data-section-text="PeriodicSegmentalConstraint"><h1 id="periodicsegmentalconstraint">PeriodicSegmentalConstraint</h1><p>PeriodicSegmentalConstraint enforces macro-micro periodic conditions between secondary and primary sides of a mortar interface using Lagrange multipliers.Must be used alongside EqualValueConstraint.</p><section class="scrollspy" id="8cb7b36a-5158-4084-adac-5be4d5f9bf05" data-section-level="2" data-section-text="Description"><h2 id="description">Description</h2><p>This <code>Constraint</code> demonstrates the usage of the scalar augmentation class described in <a href="MortarScalarBase.html">MortarScalarBase</a>. The other terms in the weak form are handled using the <a href="EqualValueConstraint.html">EqualValueConstraint</a> as described below.</p><p>In comparison to Dirichlet or Neumann conditions, periodic boundary conditions have been found to typically be the most accurate (fastest converging) approach for applying macro-to-micro scale transition constraints. Several methods for imposing periodic boundary conditions exist, each with pros and cons. For example, the mortar approach requires an extra Lagrange multiplier field. Alternatively, the periodic condition can be imposed by the penalty method using <a href="PenaltyPeriodicSegmentalConstraint.html">PenaltyPeriodicSegmentalConstraint</a> or one of the other periodic approaches in <code>MOOSE</code>.</p><p>This class provides the macro-micro coupling terms to implement periodic boundary conditions using the mortar method, as proposed within <a href="#reis_mortar_2014">Reis and Andrade Pires (2014)</a>. Alternatively, these equations impose an average value of the diffusive flux of a spatial variable over a domain using surface rather than volume integrals.</p><p>The strong form is posed over domain <span class="moose-katex-inline-equation" id="moose-equation-ef8d3759-69e5-4db9-aed8-8282f7b47560"><script>var element = document.getElementById("moose-equation-ef8d3759-69e5-4db9-aed8-8282f7b47560");katex.render("\\Omega", element, {displayMode:false,throwOnError:false});</script></span> with opposing boundary pairs <span class="moose-katex-inline-equation" id="moose-equation-539eed7c-377f-44da-84b6-fb0cb4bda4aa"><script>var element = document.getElementById("moose-equation-539eed7c-377f-44da-84b6-fb0cb4bda4aa");katex.render("\\Gamma^+", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-d1b3bbf3-8a4f-45d6-9d74-ed35e20b214c"><script>var element = document.getElementById("moose-equation-d1b3bbf3-8a4f-45d6-9d74-ed35e20b214c");katex.render("\\Gamma^-", element, {displayMode:false,throwOnError:false});</script></span>:</p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-dd357969-cc69-4c07-a899-937f9896485d"></span><span class="moose-katex-equation-number">(1)</span><script>var element = document.getElementById("moose-equation-dd357969-cc69-4c07-a899-937f9896485d");katex.render("\\begin{aligned}   \\nabla\\cdot D \\nabla u = 0 \\text{ in } \\Omega\\\\   \\llbracket u \\rrbracket = \\vec{\\epsilon} \\cdot \\llbracket \\vec{x} \\rrbracket \\text{ on } \\Gamma^+\\\\   D \\nabla u(\\vec{x}^+) \\cdot \\hat{n}^+ = \\lambda = -D \\nabla u(\\vec{x}^-) \\cdot \\hat{n}^- \\text{ on } \\Gamma^+\\\\   \\int_{\\Gamma^+}{\\lambda \\llbracket \\vec{x} \\rrbracket d\\Gamma} = V_0 \\vec{\\sigma} \\end{aligned}", element, {displayMode:true,throwOnError:false});</script></span><p>where <span class="moose-katex-inline-equation" id="moose-equation-65d426f3-2b57-4cf7-a48b-c15eaa31b2f9"><script>var element = document.getElementById("moose-equation-65d426f3-2b57-4cf7-a48b-c15eaa31b2f9");katex.render("\\epsilon", element, {displayMode:false,throwOnError:false});</script></span> is the average diffusive gradient to be solved for, <span class="moose-katex-inline-equation" id="moose-equation-ae9b0584-9c6d-43f2-b991-93db57da1663"><script>var element = document.getElementById("moose-equation-ae9b0584-9c6d-43f2-b991-93db57da1663");katex.render("\\sigma", element, {displayMode:false,throwOnError:false});</script></span> is the imposed average diffusive flux, and <span class="moose-katex-inline-equation" id="moose-equation-8162c279-6518-45da-bc9e-7443f1ec5f03"><script>var element = document.getElementById("moose-equation-8162c279-6518-45da-bc9e-7443f1ec5f03");katex.render("\\lambda", element, {displayMode:false,throwOnError:false});</script></span> is the Lagrange multiplier that imposes this average constraint. The jump operator is defined for a single valued or vector valued field as <span class="moose-katex-inline-equation" id="moose-equation-ee0175b7-f525-46fa-8a90-b9841a678b10"><script>var element = document.getElementById("moose-equation-ee0175b7-f525-46fa-8a90-b9841a678b10");katex.render("\\llbracket u \\rrbracket = u^{+} - u^{-}", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-35179e44-089f-484b-81de-4ea0d16046a9"><script>var element = document.getElementById("moose-equation-35179e44-089f-484b-81de-4ea0d16046a9");katex.render("\\llbracket \\vec{x} \\rrbracket = \\vec{x}^{+} - \\vec{x}^{-}", element, {displayMode:false,throwOnError:false});</script></span>, respectively.</p><p>The corresponding weak form is (using inner-product notation):</p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-de701300-9402-4841-b206-87f15ff51317"></span><span class="moose-katex-equation-number">(2)</span><script>var element = document.getElementById("moose-equation-de701300-9402-4841-b206-87f15ff51317");katex.render("\\begin{aligned}   (\\nabla \\psi, D \\nabla u)_\\Omega - \\langle \\llbracket \\psi \\rrbracket,\\lambda \\rangle _{\\Gamma^+} = 0\\\\   -\\langle \\Phi , \\llbracket u \\rrbracket \\rangle _{\\Gamma^+} + \\langle \\Phi , \\vec{\\epsilon} \\cdot \\llbracket \\vec{x} \\rrbracket \\rangle _{\\Gamma^+} = 0\\\\   \\langle \\vec{\\kappa} \\cdot \\llbracket \\vec{x} \\rrbracket, \\lambda \\rangle _{\\Gamma^+} = \\langle \\vec{\\kappa} \\cdot \\llbracket \\vec{x} \\rrbracket, \\vec{\\sigma} \\cdot \\hat{n} \\rangle _{\\Gamma^+} \\end{aligned}", element, {displayMode:true,throwOnError:false});</script></span><p>where <span class="moose-katex-inline-equation" id="moose-equation-9855ea7e-3685-4f66-baeb-5d1e1d99ceed"><script>var element = document.getElementById("moose-equation-9855ea7e-3685-4f66-baeb-5d1e1d99ceed");katex.render("\\psi", element, {displayMode:false,throwOnError:false});</script></span> is the test function of the diffusive variable <span class="moose-katex-inline-equation" id="moose-equation-366aa6cd-5e60-4847-a08e-4e960255cadb"><script>var element = document.getElementById("moose-equation-366aa6cd-5e60-4847-a08e-4e960255cadb");katex.render("u", element, {displayMode:false,throwOnError:false});</script></span>, <span class="moose-katex-inline-equation" id="moose-equation-e897fdb3-26ad-445f-b2ab-4a557cd7561b"><script>var element = document.getElementById("moose-equation-e897fdb3-26ad-445f-b2ab-4a557cd7561b");katex.render("\\Phi", element, {displayMode:false,throwOnError:false});</script></span> is the test function for the Lagrange multiplier <span class="moose-katex-inline-equation" id="moose-equation-c301cf0b-4498-4eb8-8f7c-42bec20ef289"><script>var element = document.getElementById("moose-equation-c301cf0b-4498-4eb8-8f7c-42bec20ef289");katex.render("\\lambda", element, {displayMode:false,throwOnError:false});</script></span>, and <span class="moose-katex-inline-equation" id="moose-equation-193b4270-9494-4fdf-830d-a5402bc931e8"><script>var element = document.getElementById("moose-equation-193b4270-9494-4fdf-830d-a5402bc931e8");katex.render("\\vec{\\kappa}", element, {displayMode:false,throwOnError:false});</script></span> is an arbitrary test vector (spatially uniform) to impose the constraint involving the scalar variable <span class="moose-katex-inline-equation" id="moose-equation-2a328524-9d7e-4687-b7e3-54c831b13e96"><script>var element = document.getElementById("moose-equation-2a328524-9d7e-4687-b7e3-54c831b13e96");katex.render("\\vec{\\epsilon}", element, {displayMode:false,throwOnError:false});</script></span>. As is typical for mixed-field problems with Lagrange multipliers, the shape functions for <span class="moose-katex-inline-equation" id="moose-equation-cd4470fa-1c64-4006-a7a1-3f13dc3ff309"><script>var element = document.getElementById("moose-equation-cd4470fa-1c64-4006-a7a1-3f13dc3ff309");katex.render("u", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-82388ed0-eb95-420e-81e4-a5a6d8d45bd2"><script>var element = document.getElementById("moose-equation-82388ed0-eb95-420e-81e4-a5a6d8d45bd2");katex.render("\\lambda", element, {displayMode:false,throwOnError:false});</script></span> need to be chosen to satisfy the Babuska-Brezzi inf-sup condition if stabilization is not added to the system. As discussed in <a href="#reis_mortar_2014">Reis and Andrade Pires (2014)</a>, using quadratic <span class="moose-katex-inline-equation" id="moose-equation-76f911ec-bf56-4fe1-8a65-298331c198bb"><script>var element = document.getElementById("moose-equation-76f911ec-bf56-4fe1-8a65-298331c198bb");katex.render("u", element, {displayMode:false,throwOnError:false});</script></span> and piecewise linear <span class="moose-katex-inline-equation" id="moose-equation-cb5316ba-1cb2-4579-8ed5-74e78b03ff39"><script>var element = document.getElementById("moose-equation-cb5316ba-1cb2-4579-8ed5-74e78b03ff39");katex.render("\\lambda", element, {displayMode:false,throwOnError:false});</script></span> (discontinuous at corners) provides for stable results. Note that element-discontinuous (e.g. <code>L2_LAGRANGE</code> or <code>MONOMIAL</code> basis) does not produce stable results without interpolation. An easy way to make a discontinuous <span class="moose-katex-inline-equation" id="moose-equation-bc25790e-b18d-446a-8985-2157eb18b872"><script>var element = document.getElementById("moose-equation-bc25790e-b18d-446a-8985-2157eb18b872");katex.render("\\lambda", element, {displayMode:false,throwOnError:false});</script></span> field at corners is described below.</p></section><section class="scrollspy" id="f6019ab1-3cf6-4caa-8e24-8fdcd6aecf9c" data-section-level="2" data-section-text="Input File Parameters"><h2 id="input-file-parameters">Input File Parameters</h2><p>The terms in the weak form <a href="#moose-equation-de701300-9402-4841-b206-87f15ff51317">Eq. (2)</a> are handled by several different classes. The volume integrals are handled by <a href="../kernels/Diffusion.html"><code>Diffusion</code></a> or <a href="../kernels/MatDiffusion.html"><code>MatDiffusion</code></a>. The surface terms <span class="moose-katex-inline-equation" id="moose-equation-1a7eda2b-67e7-464b-b146-f7b946176919"><script>var element = document.getElementById("moose-equation-1a7eda2b-67e7-464b-b146-f7b946176919");katex.render("\\langle \\llbracket w \\rrbracket,\\lambda \\rangle _{\\Gamma^+}", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-010312ce-af04-429a-86a7-0d43600506c2"><script>var element = document.getElementById("moose-equation-010312ce-af04-429a-86a7-0d43600506c2");katex.render("\\langle \\mu , \\llbracket u \\rrbracket \\rangle _{\\Gamma^+}", element, {displayMode:false,throwOnError:false});</script></span> are computed by <a href="EqualValueConstraint.html">EqualValueConstraint</a>. The remaining three terms are handled by this class.</p><p>Two of these objects are shown in the input file below:</p><pre style="max-height:350px;"><code class="language-moose">[Constraints&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Constraints/index.html&quot;}&gt;&gt;&gt;]
  [mortarlr]
    type = EqualValueConstraint&lt;&lt;&lt;{&quot;description&quot;: &quot;EqualValueConstraint enforces solution continuity between secondary and primary sides of a mortar interface using lagrange multipliers&quot;, &quot;href&quot;: &quot;EqualValueConstraint.html&quot;}&gt;&gt;&gt;
    primary_boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the primary boundary sideset.&quot;}&gt;&gt;&gt; = &#x27;11&#x27;
    secondary_boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the secondary boundary sideset.&quot;}&gt;&gt;&gt; = &#x27;13&#x27;
    primary_subdomain&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the primary subdomain.&quot;}&gt;&gt;&gt; = &#x27;primary_right&#x27;
    secondary_subdomain&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the secondary subdomain.&quot;}&gt;&gt;&gt; = &#x27;secondary_left&#x27;
    secondary_variable&lt;&lt;&lt;{&quot;description&quot;: &quot;Primal variable on secondary surface.&quot;}&gt;&gt;&gt; = u
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the lagrange multiplier variable that this constraint is applied to. This parameter may not be supplied in the case of using penalty methods for example&quot;}&gt;&gt;&gt; = lm1
    correct_edge_dropping&lt;&lt;&lt;{&quot;description&quot;: &quot;Whether to enable correct edge dropping treatment for mortar constraints. When disabled any Lagrange Multiplier degree of freedom on a secondary element without full primary contributions will be set (strongly) to 0.&quot;}&gt;&gt;&gt; = true
  []
  [periodiclr]
    type = PeriodicSegmentalConstraint&lt;&lt;&lt;{&quot;description&quot;: &quot;PeriodicSegmentalConstraint enforces macro-micro periodic conditions between secondary and primary sides of a mortar interface using Lagrange multipliers.Must be used alongside EqualValueConstraint.&quot;, &quot;href&quot;: &quot;PeriodicSegmentalConstraint.html&quot;}&gt;&gt;&gt;
    primary_boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the primary boundary sideset.&quot;}&gt;&gt;&gt; = &#x27;11&#x27;
    secondary_boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the secondary boundary sideset.&quot;}&gt;&gt;&gt; = &#x27;13&#x27;
    primary_subdomain&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the primary subdomain.&quot;}&gt;&gt;&gt; = &#x27;primary_right&#x27;
    secondary_subdomain&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the secondary subdomain.&quot;}&gt;&gt;&gt; = &#x27;secondary_left&#x27;
    secondary_variable&lt;&lt;&lt;{&quot;description&quot;: &quot;Primal variable on secondary surface.&quot;}&gt;&gt;&gt; = u
    epsilon&lt;&lt;&lt;{&quot;description&quot;: &quot;Primary coupled scalar variable&quot;}&gt;&gt;&gt; = epsilon
    sigma&lt;&lt;&lt;{&quot;description&quot;: &quot;Controlled scalar averaging variable&quot;}&gt;&gt;&gt; = sigma
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the lagrange multiplier variable that this constraint is applied to. This parameter may not be supplied in the case of using penalty methods for example&quot;}&gt;&gt;&gt; = lm1
    correct_edge_dropping&lt;&lt;&lt;{&quot;description&quot;: &quot;Whether to enable correct edge dropping treatment for mortar constraints. When disabled any Lagrange Multiplier degree of freedom on a secondary element without full primary contributions will be set (strongly) to 0.&quot;}&gt;&gt;&gt; = true
  []
  [mortarbt]
    type = EqualValueConstraint&lt;&lt;&lt;{&quot;description&quot;: &quot;EqualValueConstraint enforces solution continuity between secondary and primary sides of a mortar interface using lagrange multipliers&quot;, &quot;href&quot;: &quot;EqualValueConstraint.html&quot;}&gt;&gt;&gt;
    primary_boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the primary boundary sideset.&quot;}&gt;&gt;&gt; = &#x27;12&#x27;
    secondary_boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the secondary boundary sideset.&quot;}&gt;&gt;&gt; = &#x27;10&#x27;
    primary_subdomain&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the primary subdomain.&quot;}&gt;&gt;&gt; = &#x27;primary_top&#x27;
    secondary_subdomain&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the secondary subdomain.&quot;}&gt;&gt;&gt; = &#x27;secondary_bottom&#x27;
    secondary_variable&lt;&lt;&lt;{&quot;description&quot;: &quot;Primal variable on secondary surface.&quot;}&gt;&gt;&gt; = u
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the lagrange multiplier variable that this constraint is applied to. This parameter may not be supplied in the case of using penalty methods for example&quot;}&gt;&gt;&gt; = lm2
    correct_edge_dropping&lt;&lt;&lt;{&quot;description&quot;: &quot;Whether to enable correct edge dropping treatment for mortar constraints. When disabled any Lagrange Multiplier degree of freedom on a secondary element without full primary contributions will be set (strongly) to 0.&quot;}&gt;&gt;&gt; = true
  []
  [periodicbt]
    type = PeriodicSegmentalConstraint&lt;&lt;&lt;{&quot;description&quot;: &quot;PeriodicSegmentalConstraint enforces macro-micro periodic conditions between secondary and primary sides of a mortar interface using Lagrange multipliers.Must be used alongside EqualValueConstraint.&quot;, &quot;href&quot;: &quot;PeriodicSegmentalConstraint.html&quot;}&gt;&gt;&gt;
    primary_boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the primary boundary sideset.&quot;}&gt;&gt;&gt; = &#x27;12&#x27;
    secondary_boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the secondary boundary sideset.&quot;}&gt;&gt;&gt; = &#x27;10&#x27;
    primary_subdomain&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the primary subdomain.&quot;}&gt;&gt;&gt; = &#x27;primary_top&#x27;
    secondary_subdomain&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the secondary subdomain.&quot;}&gt;&gt;&gt; = &#x27;secondary_bottom&#x27;
    secondary_variable&lt;&lt;&lt;{&quot;description&quot;: &quot;Primal variable on secondary surface.&quot;}&gt;&gt;&gt; = u
    epsilon&lt;&lt;&lt;{&quot;description&quot;: &quot;Primary coupled scalar variable&quot;}&gt;&gt;&gt; = epsilon
    sigma&lt;&lt;&lt;{&quot;description&quot;: &quot;Controlled scalar averaging variable&quot;}&gt;&gt;&gt; = sigma
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the lagrange multiplier variable that this constraint is applied to. This parameter may not be supplied in the case of using penalty methods for example&quot;}&gt;&gt;&gt; = lm2
    correct_edge_dropping&lt;&lt;&lt;{&quot;description&quot;: &quot;Whether to enable correct edge dropping treatment for mortar constraints. When disabled any Lagrange Multiplier degree of freedom on a secondary element without full primary contributions will be set (strongly) to 0.&quot;}&gt;&gt;&gt; = true
  []
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#d8002eb0-15d6-4403-8038-0ce361d4662e">(moose/test/tests/mortar/periodic_segmental_constraint/periodic_simple2d.i)</a><p>The applied macroscale diffusive flux <span class="moose-katex-inline-equation" id="moose-equation-36eed10d-2fb5-49ab-9ee0-97dcafeb2374"><script>var element = document.getElementById("moose-equation-36eed10d-2fb5-49ab-9ee0-97dcafeb2374");katex.render("\\sigma", element, {displayMode:false,throwOnError:false});</script></span> is applied as the <code>sigma</code> vector via an auxiliary scalar. The computed macroscale diffusive gradient <span class="moose-katex-inline-equation" id="moose-equation-f809d86f-9928-4db2-a0e6-0146c893aa34"><script>var element = document.getElementById("moose-equation-f809d86f-9928-4db2-a0e6-0146c893aa34");katex.render("\\epsilon", element, {displayMode:false,throwOnError:false});</script></span> is assigned in a scalar variable <code>epsilon</code>. Both of these scalars should have the same number of components as the spatial dimension of <span class="moose-katex-inline-equation" id="moose-equation-655dd203-417a-4982-bcea-551ade37d3ca"><script>var element = document.getElementById("moose-equation-655dd203-417a-4982-bcea-551ade37d3ca");katex.render("\\Omega", element, {displayMode:false,throwOnError:false});</script></span>. The volume integral of the gradient of the primary field will be constrained to <span class="moose-katex-inline-equation" id="moose-equation-6cefb363-7084-468a-a82b-03a4a78240d0"><script>var element = document.getElementById("moose-equation-6cefb363-7084-468a-a82b-03a4a78240d0");katex.render("\\epsilon", element, {displayMode:false,throwOnError:false});</script></span> in a weak sense.</p><p>Also, the <code>coupled_scalar</code> must be assigned the same scalar as <code>epsilon</code>.</p><p>The microscale diffusion variable is specified using the <code>primary_variable</code> parameter. If the solution values to be matched are between different variables, the <code>secondary_variable</code> parameter can also be supplied. The enforcement takes place using Lagrange multipliers assigned to <code>variable</code>. These same parameters must be used for the micro-micro coupling terms in the <a href="EqualValueConstraint.html">EqualValueConstraint</a> object.</p><p>The generation of the lower-dimensional mesh surfaces for <span class="moose-katex-inline-equation" id="moose-equation-87d4dc0f-284f-430b-9950-a66f7f7497f3"><script>var element = document.getElementById("moose-equation-87d4dc0f-284f-430b-9950-a66f7f7497f3");katex.render("\\Gamma^+", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-c6401aac-5bef-4776-9ef2-7d82ee3851b9"><script>var element = document.getElementById("moose-equation-c6401aac-5bef-4776-9ef2-7d82ee3851b9");katex.render("\\Gamma^-", element, {displayMode:false,throwOnError:false});</script></span> are described in the <a href="../../syntax/Constraints/index.html"><code>Mortar Constraint system</code></a>. The projection between two separated surfaces on opposite sides of the domain are naturally handled by the system. This is true for both <code>EqualValueConstraint</code> and <code>PeriodicSegmentalConstraint</code>. In fact, the meshes can be nonconforming as long as the geometry is conforming, although the choice of <span class="moose-katex-inline-equation" id="moose-equation-90026a15-db55-4634-9d79-ef01e906412e"><script>var element = document.getElementById("moose-equation-90026a15-db55-4634-9d79-ef01e906412e");katex.render("\\lambda", element, {displayMode:false,throwOnError:false});</script></span> discretization becomes more delicate. Note that the <code>periodic</code> parameter is NOT needed, but if it is applied then it should be the same for BOTH <code>EqualValueConstraint</code> and <code>PeriodicSegmentalConstraint</code>.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note:</span>Parallel offsets</div><div class="card-content"><div class="moose-alert-content"><p>Due to current restrictions on <code>AutomaticMortarGeneration</code>, the opposing surfaces must be directly opposite along the unit normal direction.</p></div></div></div><p>As mentioned above, the <span class="moose-katex-inline-equation" id="moose-equation-43c9049b-df41-4272-9a43-70b0655a5bd9"><script>var element = document.getElementById("moose-equation-43c9049b-df41-4272-9a43-70b0655a5bd9");katex.render("\\lambda", element, {displayMode:false,throwOnError:false});</script></span> discretization needs to be continuous along patches of element faces (<code>LAGRANGE</code>, not <code>MONOMIAL</code>) in order to be stable, but must be discontinuous along corners of the mesh where the outward unit normal <span class="moose-katex-inline-equation" id="moose-equation-868190fe-a2a4-48ea-b406-2163bbc324b6"><script>var element = document.getElementById("moose-equation-868190fe-a2a4-48ea-b406-2163bbc324b6");katex.render("\\hat{n}", element, {displayMode:false,throwOnError:false});</script></span> is discontinuous since it is a flux variable (see the third condition <a href="#moose-equation-dd357969-cc69-4c07-a899-937f9896485d">Eq. (1)</a>). An easy way to do this is to make a separate <code>LAGRANGE</code> variable for each &#x27;face&#x27; of the model with different <span class="moose-katex-inline-equation" id="moose-equation-b59e117c-4404-49bd-a68f-53b54b8b575f"><script>var element = document.getElementById("moose-equation-b59e117c-4404-49bd-a68f-53b54b8b575f");katex.render("\\hat{n}", element, {displayMode:false,throwOnError:false});</script></span>, which usually corresponds with different named side-sets or boundaries used for creating lower-dimensional mesh surfaces. This approach is demonstrated in many of the test input files.</p><div class="card moose-alert moose-alert-warning"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">warning</i><span class="moose-alert-title-brand">warning:</span>Solver Type NEWTON</div><div class="card-content"><div class="moose-alert-content"><p>The <code>PJFNK</code> solver does not perform well for discrete systems lacking terms on the diagonal of the Jacobian matrix, such as this mortar method. Thus, the <code>NEWTON</code> solver is recommended.</p></div></div></div></section><section class="scrollspy" id="0576f385-138b-46f1-9404-ad03308bd140" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="ff54d52c-2bf7-4b38-8f32-ecbc8e6ec727" data-section-level="3" data-section-text="Required Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">primary_boundary</span><span class="moose-parameter-header-description">The name of the primary boundary sideset.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>BoundaryName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The name of the primary boundary sideset.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">primary_subdomain</span><span class="moose-parameter-header-description">The name of the primary subdomain.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>SubdomainName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The name of the primary subdomain.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">secondary_boundary</span><span class="moose-parameter-header-description">The name of the secondary boundary sideset.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>BoundaryName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The name of the secondary boundary sideset.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">secondary_subdomain</span><span class="moose-parameter-header-description">The name of the secondary subdomain.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>SubdomainName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The name of the secondary subdomain.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">sigma</span><span class="moose-parameter-header-description">Controlled scalar averaging variable</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;VariableName&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Controlled scalar averaging variable</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Required Parameters</h3></summary></details></section><section id="7ab86acf-5b25-42ca-9814-ebdbfcdd5b0c" data-section-level="3" data-section-text="Optional Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">aux_lm</span><span class="moose-parameter-header-description">Auxiliary Lagrange multiplier variable that is utilized together with the Petrov-Galerkin approach.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;VariableName&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Auxiliary Lagrange multiplier variable that is utilized together with the Petrov-Galerkin approach.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">compute_lm_residuals</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Whether to compute Lagrange Multiplier residuals</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether to compute Lagrange Multiplier residuals</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">compute_primal_residuals</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Whether to compute residuals for the primal variable.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether to compute residuals for the primal variable.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">compute_scalar_residuals</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Whether to compute scalar residuals</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether to compute scalar residuals</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">correct_edge_dropping</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether to enable correct edge dropping treatment for mortar constraints. When disabled any Lagrange Multiplier degree of freedom on a secondary element without full primary contributions will be set (strongly) to 0.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether to enable correct edge dropping treatment for mortar constraints. When disabled any Lagrange Multiplier degree of freedom on a secondary element without full primary contributions will be set (strongly) to 0.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">debug_mesh</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether this constraint is going to enable mortar segment mesh debug information. An exodusfile will be generated if the user sets this flag to true</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether this constraint is going to enable mortar segment mesh debug information. An exodusfile will be generated if the user sets this flag to true</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">epsilon</span><span class="moose-parameter-header-description">Primary coupled scalar variable</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;VariableName&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Primary coupled scalar variable</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">ghost_higher_d_neighbors</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether we should ghost higher-dimensional neighbors. This is necessary when we are doing second order mortar with finite volume primal variables, because in order for the method to be second order we must use cell gradients, which couples in the neighbor cells.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether we should ghost higher-dimensional neighbors. This is necessary when we are doing second order mortar with finite volume primal variables, because in order for the method to be second order we must use cell gradients, which couples in the neighbor cells.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">ghost_point_neighbors</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether we should ghost point neighbors of secondary face elements, and consequently also their mortar interface couples.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether we should ghost point neighbors of secondary face elements, and consequently also their mortar interface couples.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">interpolate_normals</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Whether to interpolate the nodal normals (e.g. classic idea of evaluating field at quadrature points). If this is set to false, then non-interpolated nodal normals will be used, and then the _normals member should be indexed with _i instead of _qp</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether to interpolate the nodal normals (e.g. classic idea of evaluating field at quadrature points). If this is set to false, then non-interpolated nodal normals will be used, and then the _normals member should be indexed with _i instead of _qp</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">matrix_only</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether this object is only doing assembly to matrices (no vectors)</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether this object is only doing assembly to matrices (no vectors)</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">minimum_projection_angle</span><span class="moose-parameter-header-default">40</span><span class="moose-parameter-header-description">Parameter to control which angle (in degrees) is admissible for the creation of mortar segments.  If set to a value close to zero, very oblique projections are allowed, which can result in mortar segments solving physics not meaningfully, and overprojection of primary nodes onto the mortar segment mesh in extreme cases. This parameter is mostly intended for mortar mesh debugging purposes in two dimensions.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>40</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Parameter to control which angle (in degrees) is admissible for the creation of mortar segments.  If set to a value close to zero, very oblique projections are allowed, which can result in mortar segments solving physics not meaningfully, and overprojection of primary nodes onto the mortar segment mesh in extreme cases. This parameter is mostly intended for mortar mesh debugging purposes in two dimensions.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">periodic</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether this constraint is going to be used to enforce a periodic condition. This has the effect of changing the normals vector for projection from outward to inward facing</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether this constraint is going to be used to enforce a periodic condition. This has the effect of changing the normals vector for projection from outward to inward facing</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">primary_variable</span><span class="moose-parameter-header-description">Primal variable on primary surface. If this parameter is not provided then the primary variable will be initialized to the secondary variable</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>VariableName</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Primal variable on primary surface. If this parameter is not provided then the primary variable will be initialized to the secondary variable</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">quadrature</span><span class="moose-parameter-header-default">DEFAULT</span><span class="moose-parameter-header-description">Quadrature rule to use on mortar segments. For 2D mortar DEFAULT is recommended. For 3D mortar, QUAD meshes are integrated using triangle mortar segments. While DEFAULT quadrature order is typically sufficiently accurate, exact integration of QUAD mortar faces requires SECOND order quadrature for FIRST variables and FOURTH order quadrature for SECOND order variables.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>DEFAULT</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>DEFAULT, FIRST, SECOND, THIRD, FOURTH</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Quadrature rule to use on mortar segments. For 2D mortar DEFAULT is recommended. For 3D mortar, QUAD meshes are integrated using triangle mortar segments. While DEFAULT quadrature order is typically sufficiently accurate, exact integration of QUAD mortar faces requires SECOND order quadrature for FIRST variables and FOURTH order quadrature for SECOND order variables.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">secondary_variable</span><span class="moose-parameter-header-description">Primal variable on secondary surface.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>VariableName</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Primal variable on secondary surface.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">use_petrov_galerkin</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether to use the Petrov-Galerkin approach for the mortar-based constraints. If set to true, we use the standard basis as the test function and dual basis as the shape function for the interpolation of the Lagrange multiplier variable.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether to use the Petrov-Galerkin approach for the mortar-based constraints. If set to true, we use the standard basis as the test function and dual basis as the shape function for the interpolation of the Lagrange multiplier variable.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">variable</span><span class="moose-parameter-header-description">The name of the lagrange multiplier variable that this constraint is applied to. This parameter may not be supplied in the case of using penalty methods for example</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>NonlinearVariableName</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The name of the lagrange multiplier variable that this constraint is applied to. This parameter may not be supplied in the case of using penalty methods for example</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="71450024-79d9-413d-9691-d2df5fdc4569" data-section-level="3" data-section-text="Contribution To Tagged Field Data Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">absolute_value_vector_tags</span><span class="moose-parameter-header-description">The tags for the vectors this residual object should fill with the absolute value of the residual contribution</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;TagName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The tags for the vectors this residual object should fill with the absolute value of the residual contribution</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">extra_matrix_tags</span><span class="moose-parameter-header-description">The extra tags for the matrices this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;TagName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The extra tags for the matrices this Kernel should fill</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">extra_vector_tags</span><span class="moose-parameter-header-description">The extra tags for the vectors this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;TagName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The extra tags for the vectors this Kernel should fill</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">matrix_tags</span><span class="moose-parameter-header-default">system</span><span class="moose-parameter-header-description">The tag for the matrices this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>system</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MultiMooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>nontime, system</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The tag for the matrices this Kernel should fill</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">vector_tags</span><span class="moose-parameter-header-default">nontime</span><span class="moose-parameter-header-description">The tag for the vectors this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>nontime</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MultiMooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>nontime, time</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The tag for the vectors this Kernel should fill</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Contribution To Tagged Field Data Parameters</h3></summary></details></section><section id="fab0828e-712d-4478-b24d-31aa1dd74083" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>Yes</p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">implicit</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Determines whether this object is calculated using an implicit or explicit form</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Determines whether this object is calculated using an implicit or explicit form</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">search_method</span><span class="moose-parameter-header-default">nearest_node_connected_sides</span><span class="moose-parameter-header-description">Choice of search algorithm.  All options begin by finding the nearest node in the primary boundary to a query point in the secondary boundary.  In the default nearest_node_connected_sides algorithm, primary boundary elements are searched iff that nearest node is one of their nodes.  This is fast to determine via a pregenerated node-to-elem map and is robust on conforming meshes.  In the optional all_proximate_sides algorithm, primary boundary elements are searched iff they touch that nearest node, even if they are not topologically connected to it.  This is more CPU-intensive but is necessary for robustness on any boundary surfaces which has disconnections (such as Flex IGA meshes) or non-conformity (such as hanging nodes in adaptively h-refined meshes).</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>nearest_node_connected_sides</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>nearest_node_connected_sides, all_proximate_sides</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Choice of search algorithm.  All options begin by finding the nearest node in the primary boundary to a query point in the secondary boundary.  In the default nearest_node_connected_sides algorithm, primary boundary elements are searched iff that nearest node is one of their nodes.  This is fast to determine via a pregenerated node-to-elem map and is robust on conforming meshes.  In the optional all_proximate_sides algorithm, primary boundary elements are searched iff they touch that nearest node, even if they are not topologically connected to it.  This is more CPU-intensive but is necessary for robustness on any boundary surfaces which has disconnections (such as Flex IGA meshes) or non-conformity (such as hanging nodes in adaptively h-refined meshes).</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">seed</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">The seed for the master random number generator</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The seed for the master random number generator</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">use_displaced_mesh</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section><section id="ac483857-b329-4be7-b1d7-219a26f364c1" data-section-level="3" data-section-text="Material Property Retrieval Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">prop_getter_suffix</span><span class="moose-parameter-header-description">An optional suffix parameter that can be appended to any attempt to retrieve/get material properties. The suffix will be prepended with a '_' character.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MaterialPropertyName</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>An optional suffix parameter that can be appended to any attempt to retrieve/get material properties. The suffix will be prepended with a '_' character.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">use_interpolated_state</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">For the old and older state use projected material properties interpolated at the quadrature points. To set up projection use the ProjectedStatefulMaterialStorageAction.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>For the old and older state use projected material properties interpolated at the quadrature points. To set up projection use the ProjectedStatefulMaterialStorageAction.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Material Property Retrieval Parameters</h3></summary></details></section></section><section class="scrollspy" id="85cc0290-e03a-4de0-be20-44fa9ea4e245" data-section-level="2" data-section-text="References"><h2 id="references">References</h2><div class="moose-bibliography"><ol><li id="reis_mortar_2014">F.&nbsp;J.&nbsp;P. Reis and F.&nbsp;M. Andrade&nbsp;Pires.
A mortar based approach for the enforcement of periodic boundary conditions on arbitrarily generated meshes.
<em>Computer Methods in Applied Mechanics and Engineering</em>, 274:168–191, June 2014.
URL: <a href="http://www.sciencedirect.com/science/article/pii/S0045782514000528">http://www.sciencedirect.com/science/article/pii/S0045782514000528</a>, <a href="https://doi.org/10.1016/j.cma.2014.01.029">doi:10.1016/j.cma.2014.01.029</a>.<a href="#ff417d34-e722-403a-8d00-0244fd2f6ed1" class="modal-trigger moose-bibtex-modal" style="padding-left:10px;">[BibTeX]</a><div class="modal" id="ff417d34-e722-403a-8d00-0244fd2f6ed1"><div class="modal-content"><pre style="line-height:1.25;"><code class="language-latex">@article{reis_mortar_2014,
    author = "Reis, F. J. P. and Andrade Pires, F. M.",
    title = "A mortar based approach for the enforcement of periodic boundary conditions on arbitrarily generated meshes",
    volume = "274",
    issn = "0045-7825",
    url = "http://www.sciencedirect.com/science/article/pii/S0045782514000528",
    doi = "10.1016/j.cma.2014.01.029",
    journal = "Computer Methods in Applied Mechanics and Engineering",
    month = "June",
    year = "2014",
    pages = "168--191"
}
</code></pre></div></div></li></ol></div></section></section><div class="moose-modal modal" id="d8002eb0-15d6-4403-8038-0ce361d4662e"><div class="modal-content"><h4>(moose/test/tests/mortar/periodic_segmental_constraint/periodic_simple2d.i)</h4><pre style="max-height:350px;"><code class="language-moose">[Mesh]
  [left_block]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = -1.0
    xmax = 1.0
    ymin = -1.0
    ymax = 1.0
    nx = 2
    ny = 2
    elem_type = QUAD9
  []
  [left_block_sidesets]
    type = RenameBoundaryGenerator
    input = left_block
    old_boundary = &#x27;0 1 2 3&#x27;
    new_boundary = &#x27;10 11 12 13&#x27;
  []
  [left_block_id]
    type = SubdomainIDGenerator
    input = left_block_sidesets
    subdomain_id = 1
  []
  [left]
    type = LowerDBlockFromSidesetGenerator
    input = left_block_id
    sidesets = &#x27;13&#x27;
    new_block_id = &#x27;10003&#x27;
    new_block_name = &#x27;secondary_left&#x27;
  []
  [right]
    type = LowerDBlockFromSidesetGenerator
    input = left
    sidesets = &#x27;11&#x27;
    new_block_id = &#x27;10001&#x27;
    new_block_name = &#x27;primary_right&#x27;
  []
  [bottom]
    type = LowerDBlockFromSidesetGenerator
    input = right
    sidesets = &#x27;10&#x27;
    new_block_id = &#x27;10000&#x27;
    new_block_name = &#x27;secondary_bottom&#x27;
  []
  [top]
    type = LowerDBlockFromSidesetGenerator
    input = bottom
    sidesets = &#x27;12&#x27;
    new_block_id = &#x27;10002&#x27;
    new_block_name = &#x27;primary_top&#x27;
  []

  [corner_node]
    type = ExtraNodesetGenerator
    new_boundary = &#x27;pinned_node&#x27;
    nodes = &#x27;0&#x27;
    input = top
  []
[]

[Variables]
  [u]
    order = SECOND
    family = LAGRANGE
  []
  [epsilon]
    order = SECOND
    family = SCALAR
  []
  [./lm1]
    order = FIRST
    family = LAGRANGE
    block = secondary_left
  [../]
  [./lm2]
    order = FIRST
    family = LAGRANGE
    block = secondary_bottom
  [../]
[]

[AuxVariables]
  [sigma]
    order = SECOND
    family = SCALAR
  []
[]

[AuxScalarKernels]
  [sigma]
    type = FunctionScalarAux
    variable = sigma
    function = &#x27;1 2&#x27;
    execute_on = initial #timestep_end
  []
[]

[Kernels]
  [diff1]
    type = Diffusion
    variable = u
    block = 1
  []
[]

[Problem]
  kernel_coverage_check = false
  error_on_jacobian_nonzero_reallocation = true
[]

[BCs]
  [fix_right]
    type = DirichletBC
    variable = u
    boundary = pinned_node
    value = 0
  []
[]

[Constraints]
  [mortarlr]
    type = EqualValueConstraint
    primary_boundary = &#x27;11&#x27;
    secondary_boundary = &#x27;13&#x27;
    primary_subdomain = &#x27;primary_right&#x27;
    secondary_subdomain = &#x27;secondary_left&#x27;
    secondary_variable = u
    variable = lm1
    correct_edge_dropping = true
  []
  [periodiclr]
    type = PeriodicSegmentalConstraint
    primary_boundary = &#x27;11&#x27;
    secondary_boundary = &#x27;13&#x27;
    primary_subdomain = &#x27;primary_right&#x27;
    secondary_subdomain = &#x27;secondary_left&#x27;
    secondary_variable = u
    epsilon = epsilon
    sigma = sigma
    variable = lm1
    correct_edge_dropping = true
  []
  [mortarbt]
    type = EqualValueConstraint
    primary_boundary = &#x27;12&#x27;
    secondary_boundary = &#x27;10&#x27;
    primary_subdomain = &#x27;primary_top&#x27;
    secondary_subdomain = &#x27;secondary_bottom&#x27;
    secondary_variable = u
    variable = lm2
    correct_edge_dropping = true
  []
  [periodicbt]
    type = PeriodicSegmentalConstraint
    primary_boundary = &#x27;12&#x27;
    secondary_boundary = &#x27;10&#x27;
    primary_subdomain = &#x27;primary_top&#x27;
    secondary_subdomain = &#x27;secondary_bottom&#x27;
    secondary_variable = u
    epsilon = epsilon
    sigma = sigma
    variable = lm2
    correct_edge_dropping = true
  []
[]

[Preconditioning]
  [smp]
    full = true
    type = SMP
  []
[]

[Executioner]
  type = Steady
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type -pc_factor_shift_amount&#x27;
  petsc_options_value = &#x27;lu       NONZERO               1e-15&#x27;
  solve_type = NEWTON
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#8cb7b36a-5158-4084-adac-5be4d5f9bf05" class="tooltipped" data-position="left" data-tooltip="Description">Description</a></li><li><a href="#f6019ab1-3cf6-4caa-8e24-8fdcd6aecf9c" class="tooltipped" data-position="left" data-tooltip="Input File Parameters">Input File Parameters</a></li><li><a href="#0576f385-138b-46f1-9404-ad03308bd140" class="tooltipped" data-position="left" data-tooltip="Input Parameters">Input Parameters</a></li><li><a href="#85cc0290-e03a-4de0-be20-44fa9ea4e245" class="tooltipped" data-position="left" data-tooltip="References">References</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script><script type="text/javascript" src="../../js/moose_input_parser.js"></script>