<!DOCTYPE html><head><meta charset="UTF-8"><title>NonlinearSystemBase | Zapdos</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/zapdos.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="https://shannon-lab.github.io/zapdos" class="left moose-logo hide-on-med-and-down">Zapdos</a><a href="https://github.com/shannon-lab/zapdos" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="3e0ffc54-6636-4a62-82e5-cbefffb11d7e" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="eb43b476-15fd-4f47-b85d-020a8d256eca" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="861c307d-d32f-43a3-a87e-3811beeccbea" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#" class="sidenav-trigger" data-target="fa6332ea-0635-4023-bfe9-160a20180de9"><i class="material-icons">menu</i></a><ul class="sidenav" id="fa6332ea-0635-4023-bfe9-160a20180de9"><li><a href="#!" class="dropdown-trigger" data-target="1dae895c-3032-4505-8c6a-6ba31058ebe9" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="abdbb78a-43bc-4a13-a920-b831cc92f7e7" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="6e289463-e0d6-4a2e-b875-5e0579b0db31" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="3e0ffc54-6636-4a62-82e5-cbefffb11d7e"><li><a href="../../getting_started/installation.html">Installation</a></li><li><a href="../../getting_started/using_zapdos.html">Using Zapdos</a></li><li><a href="../../getting_started/zapdos_meshing.html">Generating Meshes</a></li></ul><ul class="dropdown-content" id="eb43b476-15fd-4f47-b85d-020a8d256eca"><li><a href="../../syntax/index.html">Complete Code Syntax</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/libmesh/classes.html">libMesh Doxygen</a></li><li><a href="../../a-to-z.html">Zapdos A to Z Index</a></li><li><a href="../../development/contributing.html">Contributing Guidelines</a></li><li><a href="../../development/code_standards.html">Code Standards</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="861c307d-d32f-43a3-a87e-3811beeccbea"><li><a href="https://github.com/shannon-lab/zapdos/discussions">Zapdos Discussions Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussions Forum</a></li><li><a href="https://mooseframework.inl.gov/">MOOSE Homepage</a></li><li><a href="../../development/moose_developer_info.html">MOOSE Developer Information</a></li></ul><ul class="dropdown-content" id="1dae895c-3032-4505-8c6a-6ba31058ebe9"><li><a href="../../getting_started/installation.html">Installation</a></li><li><a href="../../getting_started/using_zapdos.html">Using Zapdos</a></li><li><a href="../../getting_started/zapdos_meshing.html">Generating Meshes</a></li></ul><ul class="dropdown-content" id="abdbb78a-43bc-4a13-a920-b831cc92f7e7"><li><a href="../../syntax/index.html">Complete Code Syntax</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/libmesh/classes.html">libMesh Doxygen</a></li><li><a href="../../a-to-z.html">Zapdos A to Z Index</a></li><li><a href="../../development/contributing.html">Contributing Guidelines</a></li><li><a href="../../development/code_standards.html">Code Standards</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="6e289463-e0d6-4a2e-b875-5e0579b0db31"><li><a href="https://github.com/shannon-lab/zapdos/discussions">Zapdos Discussions Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussions Forum</a></li><li><a href="https://mooseframework.inl.gov/">MOOSE Homepage</a></li><li><a href="../../development/moose_developer_info.html">MOOSE Developer Information</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="https://shannon-lab.github.io/zapdos" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">systems</span><a href="#" class="breadcrumb">NonlinearSystemBase</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="5db13da5-70bf-4c2a-ae9f-f422b8d1bc49" data-section-level="1" data-section-text="NonlinearSystemBase"><h1 id="nonlinearsystembase">NonlinearSystemBase</h1><p>This class derives from <a href="SystemBase.html">SystemBase</a> and is the immediate base class for <a href="NonlinearSystem.html">NonlinearSystem</a> and NonlinearEigenSystem. In general a simulation will always have exactly one <code>NonlinearSystemBase</code> object that holds and operates on the simulation&#x27;s nonlinear variables.</p><section class="scrollspy" id="09a08209-70b8-4ae9-97b6-3ee37552c17e" data-section-level="2" data-section-text="Scaling"><h2 id="scaling">Scaling</h2><p>A critical part to an efficient nonlinear solve is an efficient and accurate linear solve. If the linear system has a poor condition number, the linear solve may be inefficient or in the case of PJFNK, may even be inaccurate. Preconditioning is meant to combat poor linear system conditioning, but it may not be helpful if the preconditioning matrix, on which the preconditioning process relies, is itself poorly conditioned. You can inspect the condition number of your preconditioning matrix for small problems (should be less than 1000 degrees of freedom) by running with the PETSc options <code>-pc_type svd
-pc_svd_monitor</code>. These options will tell you your condition number as well as how many singular values you have. If you have any singular values, then you may have omitted a boundary condition, you may have a null space (all Neumann boundary conditions for example), or you may have very poor scaling between variables in a multi-physics simulation. You may even have run into issues if you have nodal boundary conditions (which introduce values of unity on the diagonals) and the Jacobian entries from your physics (kernels) are very large. You want your condition number to be as close to unity as possible.</p><section id="a72f430c-48c1-4dcb-9634-7c2df8aa20c3" data-section-level="3" data-section-text="Automatic scaling"><h3 id="auto-scaling">Automatic scaling</h3><p>To address a poor condition number, which can often be the result of poor relative scaling between variables, you can use MOOSE&#x27;s automatic scaling feature which will bring different physics Jacobians as close to unity as possible. To turn on this feature, set the <code>automatic_scaling</code> parameter in the <code>Executioner</code> block to <code>true</code>. Additionally, if you want to update scaling factors at every time step then set <code>Executioner/compute_scaling_once=false</code>. By default this latter parameter is set to <code>true</code> in order to save computational expense.</p><p>By default scaling factors are computed solely based on information from <code>compute.*Jacobian</code> methods. However, residual information or a hybrid of Jacobian and residual information may also be used by setting the <code>Executioner</code> parameter <code>resid_vs_jac_scaling_param</code>. The default value is <code>0</code>, signaling pure Jacobian scaling. Setting a value of <code>1</code> requests pure residual scaling. Any value in-between <code>0</code> and <code>1</code> represents a hybrid of residual and Jacobian.</p><p>Another parameter relevant to automatic scaling is the <code>scaling_group_variables</code> parameter. Variables in a group will have a single common factor applied to them. Multiple groups can be used with semicolons separating them. An example of this is shown in the <code>Executioner</code> block example below where residual/Jacobian information from all the displacement (<code>disp_</code>) variables would be used to determine a single scaling factor for themselves, and similarly the residual/Jacobian information from all the velocity (<code>vel_</code>) variables would be used to determine a single scaling factor for themselves.</p><pre class="moose-pre"><code class="language-text">
[Executioner]
:
:
  automatic_scaling = true
  scaling_group_variables = &#x27;disp_x disp_y disp_z; vel_x vel_y vel_z&#x27;
:
:
[]
</code></pre><p>The current implementation of automatic scaling in MOOSE is fairly simple and proceeds according to these steps:</p><ol class="browser-default" start="1"><li><p>Compute the Jacobians and/or residuals for all <code>Kernels</code>, <code>ScalarKernels</code>, <code>NodalKernels</code>, and <code>FVKernels</code>  - If <code>off_diagonals_in_auto_scaling</code> is set to <code>true</code> in the input file,    then we aggregate all entries in a Jacobian row into a single row value    taking the absolute value of any value that is submitted to the    <code>SparseMatrix::add</code> method.  - If <code>off_diagonals_in_auto_scaling</code> is not specified or is set to <code>false</code>    in the input file, then only the diagonal entries of the Jacobian matrix    are considered  - Regardless of the value of <code>off_diagonals_in_auto_scaling</code> the result of    this operation is a <code>NumericVector</code> of data </p></li><li><p>Examine the vector of Jacobian data or residual vector for every row corresponding to a given variable (or group of variables; recall the <code>scaling_group_variables</code> parameter) and then compute a scaling factor such that the maximum absolute value of the Jacobian data vector or residual across all of a variable&#x27;s (or group of variables) rows is unity. </p></li><li><p>If a hybrid of residual and Jacobian scaling has been requested, then a single scaling factor is computed from the residual scaling factor and Jacobian scaling factor. That computation for each variable (group) is done with the following code, where <code>inverse_scaling_factor</code> actually denotes that it is the reciprocal/inverse of the final applied variable scaling factor:</p></li></ol><pre class="moose-pre"><code class="language-c++">
inverse_scaling_factors[i] =
    std::exp(_resid_vs_jac_scaling_param * std::log(resid_inverse_scaling_factors[i]) +
             (1 - _resid_vs_jac_scaling_param) * std::log(jac_inverse_scaling_factors[i]));
</code></pre><p>We only execute kernel objects because objects like <code>BoundaryConditions</code>, <code>DGKernels</code>, <code>InterfaceKernels</code>, and <code>Constraints</code> may apply penalty factors or introduce global constraints for things like Dirichlet conditions or hanging nodes in mesh adaptivity. We want our scaling factors to represent our physics, not penalties or constraints. </p></section></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#09a08209-70b8-4ae9-97b6-3ee37552c17e" class="tooltipped" data-position="left" data-tooltip="Scaling">Scaling</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>