<!DOCTYPE html><head><meta charset="UTF-8"><title>NonlinearSystem | Zapdos</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/zapdos.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Zapdos</a><a href="https://github.com/shannon-lab/zapdos" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="999b4fab-c3f8-4130-8241-d44326fd89b1" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="9d59f655-69a7-4f9c-a7d5-307abf87e6ad" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="1391cb80-3b0c-4b23-917e-a65d3dfb5990" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#" class="sidenav-trigger" data-target="2890372f-83ad-4840-8841-4ae2161fd1ea"><i class="material-icons">menu</i></a><ul class="sidenav" id="2890372f-83ad-4840-8841-4ae2161fd1ea"><li><a href="#!" class="dropdown-trigger" data-target="a3fadd57-aa52-4341-9196-7b2981f85851" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="179657d1-aa1e-409a-902c-7bddc0f1e1bb" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="955767cc-509e-4634-bf6c-80d05743e72a" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="999b4fab-c3f8-4130-8241-d44326fd89b1"><li><a href="../../getting_started/installation.html">Installation</a></li><li><a href="../../getting_started/using_zapdos.html">Using Zapdos</a></li><li><a href="../../getting_started/zapdos_meshing.html">Generating Meshes</a></li></ul><ul class="dropdown-content" id="9d59f655-69a7-4f9c-a7d5-307abf87e6ad"><li><a href="../../syntax/index.html">Complete Code Syntax</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/libmesh/classes.html">libMesh Doxygen</a></li><li><a href="../../a-to-z.html">Zapdos A to Z Index</a></li><li><a href="../../development/contributing.html">Contributing Guidelines</a></li><li><a href="../../development/code_standards.html">Code Standards</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="1391cb80-3b0c-4b23-917e-a65d3dfb5990"><li><a href="https://github.com/shannon-lab/zapdos/discussions">Zapdos Discussions Forum</a></li><li><a href="../../development/zapdos_developer_info.html">Zapdos Developer Information</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussions Forum</a></li><li><a href="https://mooseframework.inl.gov/">MOOSE Homepage</a></li><li><a href="../../development/moose_developer_info.html">MOOSE Developer Information</a></li></ul><ul class="dropdown-content" id="a3fadd57-aa52-4341-9196-7b2981f85851"><li><a href="../../getting_started/installation.html">Installation</a></li><li><a href="../../getting_started/using_zapdos.html">Using Zapdos</a></li><li><a href="../../getting_started/zapdos_meshing.html">Generating Meshes</a></li></ul><ul class="dropdown-content" id="179657d1-aa1e-409a-902c-7bddc0f1e1bb"><li><a href="../../syntax/index.html">Complete Code Syntax</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/libmesh/classes.html">libMesh Doxygen</a></li><li><a href="../../a-to-z.html">Zapdos A to Z Index</a></li><li><a href="../../development/contributing.html">Contributing Guidelines</a></li><li><a href="../../development/code_standards.html">Code Standards</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="955767cc-509e-4634-bf6c-80d05743e72a"><li><a href="https://github.com/shannon-lab/zapdos/discussions">Zapdos Discussions Forum</a></li><li><a href="../../development/zapdos_developer_info.html">Zapdos Developer Information</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussions Forum</a></li><li><a href="https://mooseframework.inl.gov/">MOOSE Homepage</a></li><li><a href="../../development/moose_developer_info.html">MOOSE Developer Information</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">systems</span><a href="#" class="breadcrumb">NonlinearSystem</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="ee1018eb-ad18-46a0-b17a-d95ab9fa895a" data-section-level="1" data-section-text="NonlinearSystem"><h1 id="nonlinearsystem">NonlinearSystem</h1><p>The NonlinearSystem object holds the equation system created by the normal FEM process (e.g. the Matrix and RHS vector) to be solved. Normally MOOSE uses PETSc to store and solve this system. This object is where you will find the callback routines used by the PETSc solvers.</p><ul class="browser-default"><li><p><a href="NonlinearSystem.html#newtons_method">Solving Non-linear Systems</a> </p></li><li><p><a href="NonlinearSystem.html#jacobian_definition">Jacobian Definition</a> </p></li><li><p><a href="NonlinearSystem.html#linear_methods">Solving Linear Systems</a> </p></li><li><p><a href="NonlinearSystem.html#augmenting_sparsity">Augmenting Sparsity</a></p></li></ul><p>You may find some additional documentation relevant to both <code>NonlinearSystem</code> and <code>NonlinearEigenSystem</code> in <a href="NonlinearSystemBase.html">NonlinearSystemBase</a>.</p><section class="scrollspy" id="4ae9f565-fa5b-48b6-ab77-51e6a2e0e9bd" data-section-level="2" data-section-text="Solving Non - linear Systems"><h2 id="newtons_method">Solving Non-linear Systems</h2><p>Application of the finite element method converts PDE(s) into a system of nonlinear equations, <span class="moose-katex-inline-equation" id="moose-equation-89ea0e2c-6ca9-45fc-8177-e07796e24087"><script>var element = document.getElementById("moose-equation-89ea0e2c-6ca9-45fc-8177-e07796e24087");katex.render("R_i(u_h)=0, \\qquad i=1,\\ldots, N", element, {displayMode:false,throwOnError:false});</script></span>   to solve for the coefficients <span class="moose-katex-inline-equation" id="moose-equation-456cfc1d-88b7-400b-bfd8-40d98d252a53"><script>var element = document.getElementById("moose-equation-456cfc1d-88b7-400b-bfd8-40d98d252a53");katex.render("u_j, j=1,\\dots,N", element, {displayMode:false,throwOnError:false});</script></span>.</p><ul class="browser-default"><li><p>Newton&#x27;s method has good convergence properties, we use it to solve this system of nonlinear equations. </p></li><li><p>Newton&#x27;s method is a &quot;root finding&quot; method: it finds zeros of nonlinear equations. </p></li><li><p>Newton&#x27;s Method in &quot;Update Form&quot; for finding roots of the scalar equation <span class="moose-katex-inline-equation" id="moose-equation-e5abfa2b-704e-4521-90c8-11f7588f4ff1"><script>var element = document.getElementById("moose-equation-e5abfa2b-704e-4521-90c8-11f7588f4ff1");katex.render("\\begin{array}{rl}f(x)&=0, f(x): \\mathbb{R} &\\rightarrow \\mathbb{R}\\textrm{ is given by}:\\\\ f'(x_n) \\delta x_{n+1} &= -f(x_n) \\\\ x_{n+1} &= x_n + \\delta x_{n+1}\\end{array}", element, {displayMode:false,throwOnError:false});</script></span> </p></li><li><p>We don&#x27;t have just one scalar equation: we have a system of nonlinear equations. </p></li><li><p>This leads to the following form of Newton&#x27;s Method:</p><p>  <span class="moose-katex-inline-equation" id="moose-equation-495aa3d3-c36e-42b6-8936-d8d3e56e55d4"><script>var element = document.getElementById("moose-equation-495aa3d3-c36e-42b6-8936-d8d3e56e55d4");katex.render("\\begin{aligned}   \\mathbf{J}(\\vec{u}_n) \\delta\\vec{u}_{n+1} &= -\\vec{R}(\\vec{u}_n) \\\\   \\vec{u}_{n+1} &= \\vec{u}_n + \\delta\\vec{u}_{n+1}\\end{aligned}", element, {displayMode:false,throwOnError:false});</script></span></p><p></p></li><li><p>Where <span class="moose-katex-inline-equation" id="moose-equation-38e63a21-2e33-4a03-911f-8ef8d496881f"><script>var element = document.getElementById("moose-equation-38e63a21-2e33-4a03-911f-8ef8d496881f");katex.render("\\mathbf{J}(\\vec{u}_n)", element, {displayMode:false,throwOnError:false});</script></span> is the Jacobian matrix evaluated at the current iterate:   <span class="moose-katex-inline-equation" id="moose-equation-077e12c5-2635-4717-b73f-98e77a5adc8b"><script>var element = document.getElementById("moose-equation-077e12c5-2635-4717-b73f-98e77a5adc8b");katex.render("J_{ij}(\\vec{u}_n) = \\frac{\\partial R_i(\\vec{u}_n)}{\\partial u_j}", element, {displayMode:false,throwOnError:false});</script></span></p><p></p></li><li><p>Note that:   <span class="moose-katex-inline-equation" id="moose-equation-d699a7cb-af2c-4b08-bc23-4de66dadf9bd"><script>var element = document.getElementById("moose-equation-d699a7cb-af2c-4b08-bc23-4de66dadf9bd");katex.render("\\frac{\\partial u_h}{\\partial u_j} =     \\sum_k\\frac{\\partial }{\\partial u_j}\\left(u_k \\phi_k\\right) = \\phi_j   \\qquad   \\frac{\\partial \\left(\\nabla u_h\\right)}{\\partial u_j} =     \\sum_k \\frac{\\partial }{\\partial u_j}\\left(u_k \\nabla \\phi_k\\right) = \\nabla \\phi_j", element, {displayMode:false,throwOnError:false});</script></span></p></li></ul></section><section class="scrollspy" id="58c4f9d8-0ef1-4275-af16-dd5e1b2a5e53" data-section-level="2" data-section-text="Jacobian Definition"><h2 id="jacobian_definition">Jacobian Definition</h2><p>An efficient Newton solve, e.g. one that requires few &quot;nonlinear&quot; iterations, requires an accurate Jacobian matrix or an accurate approximation of its action on a vector. When no explicit matrix is formed for the Jacobian and only its action on a vector is computed, the algorithm is commonly referred to as matrix-free (PETSc jargon) or <a href="NonlinearSystem.html#JFNK">Jacobian-free</a> (MOOSE jargon). The default solve algorithm in MOOSE is <code>PJFNK</code>, or Preconditioned Jacobian-Free Newton-Krylov. &quot;Krylov&quot; refers to the <em>linear</em> solution algorithm used to solve each nonlinear iteration of the Newton algorithm. For more information on solving linear systems, please see <a href="NonlinearSystem.html#linear_methods">Solving Linear Systems</a>. Even if a Jacobian-free nonlinear algorithm is chosen, typically a good preconditioning matrix is still needed. Building the matrix can be accomplished <a href="NonlinearSystem.html#AD">automatically, using automatic differentiation</a> and/or <a href="NonlinearSystem.html#hand_coded_jac">manually</a>.</p><section id="42bea6cc-0069-46d9-afac-cdf0fd48d67a" data-section-level="3" data-section-text="Automatic Differentiation"><h3 id="AD">Automatic Differentiation</h3><p>One can elect to sacrifice some computing speed and calculate Jacobians automatically using <a href="https://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation (AD)</a>. MOOSE employs the <code>DualNumber</code> class from the <a href="https://github.com/roystgnr/MetaPhysicL">MetaPhysicL</a> package in order to enable AD. If the application developer wants to make use of AD, they should inherit from <code>ADKernel</code> as opposed to <code>Kernel</code>. Additionally, when coupling in variables, the <code>adCoupled*</code> methods should be used. For example, to retrieve a coupled value, instead of using <code>coupledValue(&quot;v&quot;)</code> in the <code>ADKernel</code> constructor, <code>adCoupledValue(&quot;v&quot;)</code> should be used. <code>adCoupledGradient</code> should replace <code>coupledGradient</code>, etc. An example of coupling in an AD variable can be found in <a class="moose-source-filename tooltipped modal-trigger" href="#aaf509dc-d4e5-4858-b7b4-794278ff1e01"><code>ADCoupledConvection.C</code></a> and <a class="moose-source-filename tooltipped modal-trigger" href="#8ff922a7-5407-4ffc-b267-93ebc6dc6e59"><code>ADCoupledConvection.h</code></a>. Moreover, material properties that may depend on the nonlinear variables should be retrieved using <code>getADMaterialProperty</code> instead of <code>getMaterialProperty</code>. They should be declared in materials using <code>declareADProperty</code>. Example AD material source and header files can be found <a class="moose-source-filename tooltipped modal-trigger" href="#77ef4016-736b-40b6-8e31-d42e2d530585">here</a> and <a class="moose-source-filename tooltipped modal-trigger" href="#c62b2d52-0176-40b7-b8a8-176038546033">here</a>; example kernel source and header files that use AD material properties can be found <a class="moose-source-filename tooltipped modal-trigger" href="#73cdd4b3-eef1-4ee4-a124-72f30b4b8d66">here</a> and <a class="moose-source-filename tooltipped modal-trigger" href="#ed5cc225-b8e1-4af5-9d85-7b628cdc2bc5">here</a>. The object central to AD computing objects is <code>ADReal</code> which is defined in <a href="../utils/MooseTypes.html"><code>MooseTypes</code></a>.</p></section><section id="53a4f5fd-9a98-4d49-8a96-e29b79c4f978" data-section-level="3" data-section-text="Traditional Hand - coded Jacobians"><h3 id="hand_coded_jac">Traditional Hand-coded Jacobians</h3><p>Finite element shape functions are introduced in the documentation section <a href="../problems/FEProblemBase.html#shape_functions">Shape Functions</a>. There we outline how our primary variables are summations of those shape functions multiplied by constant coefficients which are our degrees of freedom. At the end of <a href="NonlinearSystem.html#newtons_method">Solving Non-linear Systems</a> we gave an explicit illustration of how the derivative of a variable <code>u</code> with respect to its jth degree of freedom (<span class="moose-katex-inline-equation" id="moose-equation-7de17197-70fb-44c2-a7f5-5b9c9c545d66"><script>var element = document.getElementById("moose-equation-7de17197-70fb-44c2-a7f5-5b9c9c545d66");katex.render("u_j", element, {displayMode:false,throwOnError:false});</script></span>) is equal to the jth shape function <span class="moose-katex-inline-equation" id="moose-equation-20a937e9-8afe-4a01-9b7d-6199f504577c"><script>var element = document.getElementById("moose-equation-20a937e9-8afe-4a01-9b7d-6199f504577c");katex.render("\\phi_j", element, {displayMode:false,throwOnError:false});</script></span>. Similarly the derivative of <span class="moose-katex-inline-equation" id="moose-equation-4026c3b4-6af9-4327-a3f6-d74f0914e773"><script>var element = document.getElementById("moose-equation-4026c3b4-6af9-4327-a3f6-d74f0914e773");katex.render("\\nabla u", element, {displayMode:false,throwOnError:false});</script></span> with respect to <span class="moose-katex-inline-equation" id="moose-equation-dc207bd8-3e1d-4b32-8c17-92d63485db7e"><script>var element = document.getElementById("moose-equation-dc207bd8-3e1d-4b32-8c17-92d63485db7e");katex.render("u_j", element, {displayMode:false,throwOnError:false});</script></span> is equal to <span class="moose-katex-inline-equation" id="moose-equation-aaa3648d-49c0-4ddb-82c8-3e09b557172d"><script>var element = document.getElementById("moose-equation-aaa3648d-49c0-4ddb-82c8-3e09b557172d");katex.render("\\nabla \\phi_j", element, {displayMode:false,throwOnError:false});</script></span>. The code expression  <code>_phi[_j][_qp]</code> represents <span class="moose-katex-inline-equation" id="moose-equation-bbe888c2-83e7-46b8-871d-768212602659"><script>var element = document.getElementById("moose-equation-bbe888c2-83e7-46b8-871d-768212602659");katex.render("\\frac{\\partial u}{\\partial u_j}", element, {displayMode:false,throwOnError:false});</script></span> in any MOOSE framework residual and Jacobian computing objects such as kernels and boundary conditions.</p><p>Any MOOSE kernel may have an arbitrary number of variables coupled into it. If these coupled variables use the same shape function family and order, then their associated <span class="moose-katex-inline-equation" id="moose-equation-c50b0d8b-c5f1-4135-ba69-58e29dce7094"><script>var element = document.getElementById("moose-equation-c50b0d8b-c5f1-4135-ba69-58e29dce7094");katex.render("\\phi_j", element, {displayMode:false,throwOnError:false});</script></span>s will be equivalent. However, if <code>u</code> and <code>v</code> use different shape functions then <span class="moose-katex-inline-equation" id="moose-equation-5ee033bc-2d3c-487d-8e64-3d53b8a17f79"><script>var element = document.getElementById("moose-equation-5ee033bc-2d3c-487d-8e64-3d53b8a17f79");katex.render("\\phi_{j,u} \\ne \\phi_{j,v}", element, {displayMode:false,throwOnError:false});</script></span>. As a developer, however, you do not <em></em><em>in most cases</em><em></em> have to worry about these differences in <span class="moose-katex-inline-equation" id="moose-equation-db786cd6-c1d9-4ff4-a9a6-ed7d988b0951"><script>var element = document.getElementById("moose-equation-db786cd6-c1d9-4ff4-a9a6-ed7d988b0951");katex.render("\\phi", element, {displayMode:false,throwOnError:false});</script></span>. MOOSE automatically updates the object member variable <code>_phi</code> to use the shape functions of the variable for whom the Jacobian is currently being computed. <em></em><em>However</em><em></em>, if the primary variable <code>u</code> is a scalar-valued (single-component) finite element variable and the coupled variable <code>v</code> is a vector-valued (multi-component) finite element variable (or visa versa), then you must introduce an additional member variable to represent the shape functions of the vector-valued (scalar-valued) variable. The name of this variable is up to the developer, but we suggest perhaps a <code>_standard_</code> prefix for scalar valued finite-element variables and <code>_vector_</code> for vector valued finite-element variables. The <code>_standard_</code> prefix is suggested over <code>_scalar_</code> so as not to be confused with a <code>MooseVariableScalar</code>, which only has a single value over the entire spatial domain. An example constructor for a standard kernel that couples in a vector-valued FE variable is shown below:</p><pre class="moose-pre"><code class="language-text">
EFieldAdvection::EFieldAdvection(const InputParameters &amp; parameters)
  : Kernel(parameters),
    _efield_id(coupled(&quot;efield&quot;)),
    _efield(coupledVectorValue(&quot;efield&quot;)),
    _efield_var(*getVectorVar(&quot;efield&quot;, 0)),
    _vector_phi(_assembly.phi(_efield_var)),
    _mobility(getParam&lt;Real&gt;(&quot;mobility&quot;))
{
}
</code></pre><p>The associated declarations are:</p><pre class="moose-pre"><code class="language-text">
  const unsigned int _efield_id;
  const VectorVariableValue &amp; _efield;
  VectorMooseVariable &amp; _efield_var;
  const VectorVariablePhiValue &amp; _vector_phi;
  const Real _mobility;
  Real _sgn;
</code></pre><p>Residual, on-diagonal, and off-diagonal methods are respectively</p><pre class="moose-pre"><code class="language-text">
Real
EFieldAdvection::computeQpResidual()
{
  return -_grad_test[_i][_qp] * _sgn * _mobility * _efield[_qp] * _u[_qp];
}
</code></pre><p>and</p><pre class="moose-pre"><code class="language-text">
Real
EFieldAdvection::computeQpJacobian()
{
  return -_grad_test[_i][_qp] * _sgn * _mobility * _efield[_qp] * _phi[_j][_qp];
}
</code></pre><p>and</p><pre class="moose-pre"><code class="language-text">
Real
EFieldAdvection::computeQpOffDiagJacobian(unsigned int jvar)
{
  if (jvar == _efield_id)
    return -_grad_test[_i][_qp] * _sgn * _mobility * _vector_phi[_j][_qp] * _u[_qp];
  else
    return 0;
}

```
An example constructor for a vector kernel that couples in a
scalar-valued FE variable is shown below:

```
VectorCoupledGradientTimeDerivative::VectorCoupledGradientTimeDerivative(
    const InputParameters &amp; parameters)
  : VectorKernel(parameters),
    _grad_v_dot(coupledGradientDot(&quot;v&quot;)),
    _d_grad_v_dot_dv(coupledDotDu(&quot;v&quot;)),
    _v_id(coupled(&quot;v&quot;)),
    _v_var(*getVar(&quot;v&quot;, 0)),
    _standard_grad_phi(_assembly.gradPhi(_v_var))
{
}

```
The associated declarations are:

```
  const VariableGradient &amp; _grad_v_dot;
  const VariableValue &amp; _d_grad_v_dot_dv;
  const unsigned _v_id;
  MooseVariable &amp; _v_var;
  const VariablePhiGradient &amp; _standard_grad_phi;
</code></pre><p>Residual and off-diagonal Jacobian methods are respectively:</p><pre class="moose-pre"><code class="language-text">
Real
VectorCoupledGradientTimeDerivative::computeQpResidual()
{
  return _test[_i][_qp] * _grad_v_dot[_qp];
}
</code></pre><p>and</p><pre class="moose-pre"><code class="language-text">
Real
VectorCoupledGradientTimeDerivative::computeQpOffDiagJacobian(unsigned jvar)
{
  if (jvar == _v_id)
    return _test[_i][_qp] * _d_grad_v_dot_dv[_qp] * _standard_grad_phi[_j][_qp];

  else
    return 0.;
}
</code></pre><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note:</span>Flexibility</div><div class="card-content"><div class="moose-alert-content"><p>Note that only one member is needed to represent shape functions for standard     <code>MooseVariable</code>s and <code>VectorMooseVariable</code>s. For example, if the vector-variables     <code>v</code> and <code>w</code> are coupled into a standard kernel for <code>u</code>, only a single     <code>_vector_phi</code> member needs to be added; there is not need for both a     <code>_v_phi</code> and <code>_w_phi</code>. <code>_vector_phi</code> will be automatically updated to     represent the shape functions for whichever vector variable the Jacobian is     being computed for.</p></div></div></div></section><section id="b082c57b-5451-4ecd-a40e-96d8ceefa3a0" data-section-level="3" data-section-text="Newton for a Simple Equation"><h3 id="simple_newton">Newton for a Simple Equation</h3><ul class="browser-default"><li><p>Consider the convection-diffusion equation with nonlinear <span class="moose-katex-inline-equation" id="moose-equation-750b413e-5d9f-4802-97d1-677a534512e5"><script>var element = document.getElementById("moose-equation-750b413e-5d9f-4802-97d1-677a534512e5");katex.render("k", element, {displayMode:false,throwOnError:false});</script></span>, <span class="moose-katex-inline-equation" id="moose-equation-811df03f-7f6b-4772-81e1-11957b371c0a"><script>var element = document.getElementById("moose-equation-811df03f-7f6b-4772-81e1-11957b371c0a");katex.render("\\vec{\\beta}", element, {displayMode:false,throwOnError:false});</script></span>, and <span class="moose-katex-inline-equation" id="moose-equation-07808053-d37b-431e-bc70-e37686d4eb2e"><script>var element = document.getElementById("moose-equation-07808053-d37b-431e-bc70-e37686d4eb2e");katex.render("f", element, {displayMode:false,throwOnError:false});</script></span>:   <span class="moose-katex-inline-equation" id="moose-equation-13124b57-cef7-4f0a-a2b7-480a50f11544"><script>var element = document.getElementById("moose-equation-13124b57-cef7-4f0a-a2b7-480a50f11544");katex.render("\\begin{aligned}- \\nabla\\cdot k\\nabla u + \\vec{\\beta} \\cdot \\nabla u = f\\end{aligned}", element, {displayMode:false,throwOnError:false});</script></span></p><p></p></li><li><p>The <span class="moose-katex-inline-equation" id="moose-equation-08742949-255f-44b8-944e-0dbbfba00ae2"><script>var element = document.getElementById("moose-equation-08742949-255f-44b8-944e-0dbbfba00ae2");katex.render("i^{th}", element, {displayMode:false,throwOnError:false});</script></span> component of the residual vector is:   <span class="moose-katex-inline-equation" id="moose-equation-40a0e663-f1ef-430f-88cc-a04fdeab765b"><script>var element = document.getElementById("moose-equation-40a0e663-f1ef-430f-88cc-a04fdeab765b");katex.render("\\begin{aligned}   R_i(u_h) = \\left(\\nabla\\psi_i, k\\nabla u_h \\right) - \\langle\\psi_i, k\\nabla u_h\\cdot \\hat{n} \\rangle +   \\left(\\psi_i, \\vec{\\beta} \\cdot \\nabla u_h\\right) - \\left(\\psi_i, f\\right)\\end{aligned}", element, {displayMode:false,throwOnError:false});</script></span></p></li></ul><ul class="browser-default"><li><p>Using the previously-defined rules for <span class="moose-katex-inline-equation" id="moose-equation-e37bd2a9-781c-41a2-b5b7-606f0488acb6"><script>var element = document.getElementById("moose-equation-e37bd2a9-781c-41a2-b5b7-606f0488acb6");katex.render("\\frac{\\partial u_h}{\\partial u_j}", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-7c64fca5-82ec-47b3-ac4e-6c4bb81ba4e2"><script>var element = document.getElementById("moose-equation-7c64fca5-82ec-47b3-ac4e-6c4bb81ba4e2");katex.render("\\frac{\\partial \\left(\\nabla u_h\\right)}{\\partial u_j}", element, {displayMode:false,throwOnError:false});</script></span>, the <span class="moose-katex-inline-equation" id="moose-equation-7ed50a72-393d-42b4-8bf5-b372d804b798"><script>var element = document.getElementById("moose-equation-7ed50a72-393d-42b4-8bf5-b372d804b798");katex.render("(i,j)", element, {displayMode:false,throwOnError:false});</script></span> entry of the Jacobian is then:</p></li></ul><p><span class="moose-katex-inline-equation" id="moose-equation-e97feeae-52f3-4ac9-8baa-eff5d326bc27"><script>var element = document.getElementById("moose-equation-e97feeae-52f3-4ac9-8baa-eff5d326bc27");katex.render("\\begin{aligned} J_{ij}(u_h) &= \\left(\\nabla\\psi_i, \\frac{\\partial k}{\\partial u_j}\\nabla u_h \\right) + \\left(\\nabla\\psi_i, k \\nabla \\phi_j \\right) - \\left \\langle\\psi_i, \\frac{\\partial k}{\\partial u_j}\\nabla u_h\\cdot \\hat{n} \\right\\rangle \\\\&- \\left \\langle\\psi_i, k\\nabla \\phi_j\\cdot \\hat{n} \\right\\rangle + \\left(\\psi_i, \\frac{\\partial \\vec{\\beta}}{\\partial u_j} \\cdot\\nabla u_h\\right) + \\left(\\psi_i, \\vec{\\beta} \\cdot \\nabla \\phi_j\\right) - \\left(\\psi_i, \\frac{\\partial f}{\\partial u_j}\\right)\\end{aligned}", element, {displayMode:false,throwOnError:false});</script></span></p><ul class="browser-default"><li><p>Note that even for this &quot;simple&quot; equation, the Jacobian entries are nontrivial: they depend on the partial derivatives of <span class="moose-katex-inline-equation" id="moose-equation-85b688d3-098e-4a69-b096-cef33def736a"><script>var element = document.getElementById("moose-equation-85b688d3-098e-4a69-b096-cef33def736a");katex.render("k", element, {displayMode:false,throwOnError:false});</script></span>, <span class="moose-katex-inline-equation" id="moose-equation-83d4be90-33de-4701-ae7c-26296f32c7a2"><script>var element = document.getElementById("moose-equation-83d4be90-33de-4701-ae7c-26296f32c7a2");katex.render("\\vec{\\beta}", element, {displayMode:false,throwOnError:false});</script></span>, and <span class="moose-katex-inline-equation" id="moose-equation-ec1a1011-8f92-4e8f-8fba-d20a07ee56c6"><script>var element = document.getElementById("moose-equation-ec1a1011-8f92-4e8f-8fba-d20a07ee56c6");katex.render("f", element, {displayMode:false,throwOnError:false});</script></span>, which may be difficult or time-consuming to compute analytically.</p><p></p></li><li><p>In a multiphysics setting with many coupled equations and complicated material properties, the Jacobian might be extremely difficult to determine.</p></li></ul></section><section id="774958c1-d7cf-47fc-aaae-0f20afbb8dc1" data-section-level="3" data-section-text="Chain Rule"><h3 id="chain_rule">Chain Rule</h3><ul class="browser-default"><li><p>On the previous slide, the term <span class="moose-katex-inline-equation" id="moose-equation-24bad666-5431-41f5-a65f-0cffb25f4b21"><script>var element = document.getElementById("moose-equation-24bad666-5431-41f5-a65f-0cffb25f4b21");katex.render("\\frac{\\partial f}{\\partial u_j}", element, {displayMode:false,throwOnError:false});</script></span> was used, where <span class="moose-katex-inline-equation" id="moose-equation-9236d2cf-1496-4dd6-9e4e-c9f73250ba8a"><script>var element = document.getElementById("moose-equation-9236d2cf-1496-4dd6-9e4e-c9f73250ba8a");katex.render("f", element, {displayMode:false,throwOnError:false});</script></span> was a nonlinear forcing function.</p><p></p></li><li><p>The chain rule allows us to write this term as</p><p><span class="moose-katex-inline-equation" id="moose-equation-9332c2eb-c95b-4162-92de-cdac71fe5bba"><script>var element = document.getElementById("moose-equation-9332c2eb-c95b-4162-92de-cdac71fe5bba");katex.render("\\begin{aligned}   \\frac{\\partial f}{\\partial u_j} &= \\frac{\\partial f}{\\partial u_h} \\frac{\\partial u_h}{\\partial u_j}   \\\\   &=\\frac{\\partial f}{\\partial u_h} \\phi_j\\end{aligned}", element, {displayMode:false,throwOnError:false});</script></span></p><p></p></li><li><p>If a functional form of <span class="moose-katex-inline-equation" id="moose-equation-ad878e22-8734-4228-bb0f-cf67b5293b3c"><script>var element = document.getElementById("moose-equation-ad878e22-8734-4228-bb0f-cf67b5293b3c");katex.render("f", element, {displayMode:false,throwOnError:false});</script></span> is known, e.g. <span class="moose-katex-inline-equation" id="moose-equation-8ec6caba-ae06-4281-85ed-9bed7d53be43"><script>var element = document.getElementById("moose-equation-8ec6caba-ae06-4281-85ed-9bed7d53be43");katex.render("f(u) = \\sin(u)", element, {displayMode:false,throwOnError:false});</script></span>, this formula implies that its Jacobian contribution is given by</p><p> <span class="moose-katex-inline-equation" id="moose-equation-e7bada0c-0eda-47c8-b1ce-913401673f3e"><script>var element = document.getElementById("moose-equation-e7bada0c-0eda-47c8-b1ce-913401673f3e");katex.render("\\frac{\\partial f}{\\partial u_j} = \\cos(u_h) \\phi_j", element, {displayMode:false,throwOnError:false});</script></span></p></li></ul></section><section id="8a01afaa-a2af-482c-88fd-eccce8823bc6" data-section-level="3" data-section-text="Jacobian - Free Newton - Krylov"><h3 id="JFNK">Jacobian-Free Newton-Krylov</h3><ul class="browser-default"><li><p><span class="moose-katex-inline-equation" id="moose-equation-7bc916c4-c6c1-4d52-b914-9be83ab5d3a5"><script>var element = document.getElementById("moose-equation-7bc916c4-c6c1-4d52-b914-9be83ab5d3a5");katex.render("\\mathbf{J}(\\vec{u}_n)\\delta \\vec{u}_{n+1} = -\\vec{R}(\\vec{u}_n)", element, {displayMode:false,throwOnError:false});</script></span> is a linear system solved during each Newton step. </p></li><li><p>For simplicity, we can write this linear system as <span class="moose-katex-inline-equation" id="moose-equation-a848266b-76b9-4de9-bd9d-a71b8ea8d97c"><script>var element = document.getElementById("moose-equation-a848266b-76b9-4de9-bd9d-a71b8ea8d97c");katex.render("\\mathbf{A}\\vec{x} = \\vec{b}", element, {displayMode:false,throwOnError:false});</script></span>, where:   - <span class="moose-katex-inline-equation" id="moose-equation-7a639c95-7f85-4c49-9286-b9b303a5e4cc"><script>var element = document.getElementById("moose-equation-7a639c95-7f85-4c49-9286-b9b303a5e4cc");katex.render("\\mathbf{A} \\equiv \\mathbf{J}(\\vec{u}_n)", element, {displayMode:false,throwOnError:false});</script></span>   - <span class="moose-katex-inline-equation" id="moose-equation-5d96c6a7-684b-4f16-81f2-b4c0258b340f"><script>var element = document.getElementById("moose-equation-5d96c6a7-684b-4f16-81f2-b4c0258b340f");katex.render("\\vec{x} \\equiv \\delta \\vec{u}_{n+1}", element, {displayMode:false,throwOnError:false});</script></span>   - <span class="moose-katex-inline-equation" id="moose-equation-668db9c8-f1b6-46a3-9fea-7e7500a6d89d"><script>var element = document.getElementById("moose-equation-668db9c8-f1b6-46a3-9fea-7e7500a6d89d");katex.render("\\vec{b} \\equiv -\\vec{R}(\\vec{u}_n)", element, {displayMode:false,throwOnError:false});</script></span> </p></li><li><p>We employ an iterative Krylov method (e.g. GMRES) to produce a sequence of iterates <span class="moose-katex-inline-equation" id="moose-equation-e282e658-0d5f-4ba9-890b-037d42372d4d"><script>var element = document.getElementById("moose-equation-e282e658-0d5f-4ba9-890b-037d42372d4d");katex.render("\\vec{x}_k \\rightarrow \\vec{x}", element, {displayMode:false,throwOnError:false});</script></span>, <span class="moose-katex-inline-equation" id="moose-equation-f2844666-e4f3-4928-950c-51ba5ef7d2be"><script>var element = document.getElementById("moose-equation-f2844666-e4f3-4928-950c-51ba5ef7d2be");katex.render("k=1,2,\\ldots", element, {displayMode:false,throwOnError:false});</script></span> </p></li><li><p><span class="moose-katex-inline-equation" id="moose-equation-31cec74d-c1af-4d37-91ba-66f50f08055d"><script>var element = document.getElementById("moose-equation-31cec74d-c1af-4d37-91ba-66f50f08055d");katex.render("\\mathbf{A}", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-4cc93cff-0384-42b6-9e96-28b1f2415581"><script>var element = document.getElementById("moose-equation-4cc93cff-0384-42b6-9e96-28b1f2415581");katex.render("\\vec{b}", element, {displayMode:false,throwOnError:false});</script></span> remain <em>fixed</em> during the iterative process. </p></li><li><p>The &quot;linear residual&quot; at step <span class="moose-katex-inline-equation" id="moose-equation-e905fc9f-b54d-45a2-9fd0-b8ce37f426ca"><script>var element = document.getElementById("moose-equation-e905fc9f-b54d-45a2-9fd0-b8ce37f426ca");katex.render("k", element, {displayMode:false,throwOnError:false});</script></span> is defined as</p><p><span class="moose-katex-inline-equation" id="moose-equation-6e8e5857-a45f-4fc6-b8b6-d85ebed088c0"><script>var element = document.getElementById("moose-equation-6e8e5857-a45f-4fc6-b8b6-d85ebed088c0");katex.render("\\vec{\\rho}_k \\equiv \\mathbf{A}\\vec{x}_k - \\vec{b}", element, {displayMode:false,throwOnError:false});</script></span></p><p></p></li><li><p>MOOSE prints the norm of this vector, <span class="moose-katex-inline-equation" id="moose-equation-6babf6c4-f503-46b4-a6a9-a4bb23419ea2"><script>var element = document.getElementById("moose-equation-6babf6c4-f503-46b4-a6a9-a4bb23419ea2");katex.render("\\|\\vec{\\rho}_k\\|", element, {displayMode:false,throwOnError:false});</script></span>, at each iteration, if you set <code>print_linear_residuals = true</code> in the <code>Outputs</code> block.</p><p></p></li><li><p>The &quot;nonlinear residual&quot; printed by MOOSE is <span class="moose-katex-inline-equation" id="moose-equation-5c9b76b9-ff63-431d-be55-15abd1910e72"><script>var element = document.getElementById("moose-equation-5c9b76b9-ff63-431d-be55-15abd1910e72");katex.render("\\|\\vec{R}(\\vec{u}_n)\\|", element, {displayMode:false,throwOnError:false});</script></span>.</p><p></p></li><li><p>By iterate <span class="moose-katex-inline-equation" id="moose-equation-cf92ff32-4203-4666-8066-34e394312c91"><script>var element = document.getElementById("moose-equation-cf92ff32-4203-4666-8066-34e394312c91");katex.render("k", element, {displayMode:false,throwOnError:false});</script></span>, the Krylov method has constructed the subspace</p><p><span class="moose-katex-inline-equation" id="moose-equation-c8c5398d-6097-421e-aebc-587eb64f9703"><script>var element = document.getElementById("moose-equation-c8c5398d-6097-421e-aebc-587eb64f9703");katex.render("\\mathcal{K}_k = \\text{span}\\{ \\vec{b}, \\mathbf{A}\\vec{b}, \\mathbf{A}^2\\vec{b}, \\ldots, \\mathbf{A}^{k-1}\\vec{b}\\}", element, {displayMode:false,throwOnError:false});</script></span></p><p></p></li><li><p>Different Krylov methods produce the <span class="moose-katex-inline-equation" id="moose-equation-f4b700a0-2163-4197-8ad8-fb5fa2f3b5b5"><script>var element = document.getElementById("moose-equation-f4b700a0-2163-4197-8ad8-fb5fa2f3b5b5");katex.render("\\vec{x}_k", element, {displayMode:false,throwOnError:false});</script></span> iterates in different ways: </p></li><li><p>Conjugate Gradients: <span class="moose-katex-inline-equation" id="moose-equation-5b329534-230c-4c98-8130-d03fa9cc03ea"><script>var element = document.getElementById("moose-equation-5b329534-230c-4c98-8130-d03fa9cc03ea");katex.render("\\vec{\\rho}_k", element, {displayMode:false,throwOnError:false});</script></span> orthogonal to <span class="moose-katex-inline-equation" id="moose-equation-a91d27ee-544b-4dd8-b1d4-54357d0659f8"><script>var element = document.getElementById("moose-equation-a91d27ee-544b-4dd8-b1d4-54357d0659f8");katex.render("\\mathcal{K}_k", element, {displayMode:false,throwOnError:false});</script></span>. </p></li><li><p>GMRES/MINRES: <span class="moose-katex-inline-equation" id="moose-equation-d4db4995-421b-44dc-9a1a-79f9d7ca75ea"><script>var element = document.getElementById("moose-equation-d4db4995-421b-44dc-9a1a-79f9d7ca75ea");katex.render("\\vec{\\rho}_k", element, {displayMode:false,throwOnError:false});</script></span> has minimum norm for <span class="moose-katex-inline-equation" id="moose-equation-b00b9237-4147-4504-9c00-eb352549ce2f"><script>var element = document.getElementById("moose-equation-b00b9237-4147-4504-9c00-eb352549ce2f");katex.render("\\vec{x}_k", element, {displayMode:false,throwOnError:false});</script></span> in <span class="moose-katex-inline-equation" id="moose-equation-894d01f2-1bac-4522-b1f0-144e3e72f797"><script>var element = document.getElementById("moose-equation-894d01f2-1bac-4522-b1f0-144e3e72f797");katex.render("\\mathcal{K}_k", element, {displayMode:false,throwOnError:false});</script></span>. </p></li><li><p>Biconjugate Gradients: <span class="moose-katex-inline-equation" id="moose-equation-398dd0b2-506a-4d1c-879c-039ee0110bf0"><script>var element = document.getElementById("moose-equation-398dd0b2-506a-4d1c-879c-039ee0110bf0");katex.render("\\vec{\\rho}_k", element, {displayMode:false,throwOnError:false});</script></span> is orthogonal to <span class="moose-katex-inline-equation" id="moose-equation-d39517c1-3802-472c-bc59-5a736bf9f63b"><script>var element = document.getElementById("moose-equation-d39517c1-3802-472c-bc59-5a736bf9f63b");katex.render("\\mathcal{K}_k(\\mathbf{A}^T)", element, {displayMode:false,throwOnError:false});</script></span></p><p></p></li><li><p><span class="moose-katex-inline-equation" id="moose-equation-c06494e7-fc29-4c58-8a67-168073d779d3"><script>var element = document.getElementById("moose-equation-c06494e7-fc29-4c58-8a67-168073d779d3");katex.render("\\mathbf{J}", element, {displayMode:false,throwOnError:false});</script></span> is never explicitly needed to construct the subspace, only the action of <span class="moose-katex-inline-equation" id="moose-equation-8a22502e-ed51-44a9-9813-5fff9255153c"><script>var element = document.getElementById("moose-equation-8a22502e-ed51-44a9-9813-5fff9255153c");katex.render("\\mathbf{J}", element, {displayMode:false,throwOnError:false});</script></span> on a vector is required.</p></li></ul><ul class="browser-default"><li><p>This action can be approximated by:   <span class="moose-katex-inline-equation" id="moose-equation-0c90b560-61a2-45c6-8ce1-f0d4fbaff660"><script>var element = document.getElementById("moose-equation-0c90b560-61a2-45c6-8ce1-f0d4fbaff660");katex.render("\\mathbf{J}\\vec{v} \\approx \\frac{\\vec{R}(\\vec{u} + \\epsilon\\vec{v}) - \\vec{R}(\\vec{u})}{\\epsilon}", element, {displayMode:false,throwOnError:false});</script></span></p><p></p></li><li><p>This form has many advantages:   - No need to do analytic derivatives to form <span class="moose-katex-inline-equation" id="moose-equation-a8bfba38-9931-4d0c-8f86-f602f2259cde"><script>var element = document.getElementById("moose-equation-a8bfba38-9931-4d0c-8f86-f602f2259cde");katex.render("\\mathbf{J}", element, {displayMode:false,throwOnError:false});</script></span>   - No time needed to compute <span class="moose-katex-inline-equation" id="moose-equation-83d71104-d469-491d-ac37-7abcd24c5c83"><script>var element = document.getElementById("moose-equation-83d71104-d469-491d-ac37-7abcd24c5c83");katex.render("\\mathbf{J}", element, {displayMode:false,throwOnError:false});</script></span> (just residual computations)   - No space needed to store <span class="moose-katex-inline-equation" id="moose-equation-d67089d1-0c48-4396-9381-6931176163ed"><script>var element = document.getElementById("moose-equation-d67089d1-0c48-4396-9381-6931176163ed");katex.render("\\mathbf{J}", element, {displayMode:false,throwOnError:false});</script></span></p></li></ul></section></section><section class="scrollspy" id="b2733b9a-2ed2-47b3-897b-a96f51964502" data-section-level="2" data-section-text="Solving Linear Systems"><h2 id="linear_methods">Solving Linear Systems</h2><p>You will commonly hear of two ways to solve an implicit linear system of equations: directly or iteratively. A typical direct solve will perform a <a href="https://en.wikipedia.org/wiki/LU_decomposition">LU factorization</a>. Direct solves are a great tool for solving small-medium sized systems; however, they are extremely expensive when applied to large-scale problems. To solve large-scale systems, iterative methods must be used. The most successful iterative methods are Krylov methods. Krylov methods are work by finding a solution to <span class="moose-katex-inline-equation" id="moose-equation-66fb9210-21ef-4c01-9eff-2588bed8839d"><script>var element = document.getElementById("moose-equation-66fb9210-21ef-4c01-9eff-2588bed8839d");katex.render("Ax=b", element, {displayMode:false,throwOnError:false});</script></span> within a space called the <a href="https://en.wikipedia.org/wiki/Krylov_subspace">Krylov sub-space</a> which is spanned by images of <span class="moose-katex-inline-equation" id="moose-equation-7559ee6c-9926-46b4-9fad-b98845748b59"><script>var element = document.getElementById("moose-equation-7559ee6c-9926-46b4-9fad-b98845748b59");katex.render("b", element, {displayMode:false,throwOnError:false});</script></span> under powers of <span class="moose-katex-inline-equation" id="moose-equation-e0c445fc-4e9d-45fb-9cb6-28905a9a83f8"><script>var element = document.getElementById("moose-equation-e0c445fc-4e9d-45fb-9cb6-28905a9a83f8");katex.render("A", element, {displayMode:false,throwOnError:false});</script></span>. Two of the most used Krylov algorithms are <a href="https://en.wikipedia.org/wiki/Conjugate_gradient_method">Conjugate gradient</a> and <a href="https://en.wikipedia.org/wiki/GMRES">GMRES</a>. Conjugate gradient generally only works for symmetric positive-definite matrices. Because of its greater flexibility, GMRES is the default linear solution algorithm in PETSc and consequently for MOOSE.</p></section><section class="scrollspy" id="bed4a055-5163-4db2-98a7-5a129191ea95" data-section-level="2" data-section-text="Augmenting Sparsity"><h2 id="augmenting_sparsity">Augmenting Sparsity</h2><p>One such routine is <code>NonlinearSystemBase::augmentSparsity</code>, which as its name suggests augments the sparsity pattern of the matrix. Currently this method adds sparsity coming from MOOSE <code>Constraint</code> objects. It does this by querying geometric connectivity information between secondary and primary boundary pairs, and then querying the <code>DofMap</code> attached to the <code>NonlinearSystemBase</code> (through the libMesh <code>NonlinearImplicitSystem</code>) for the dof indices that exist on the elements attached to the secondary/primary nodes. The geometric connectivity information comes from <a href="../geomsearch/NearestNodeLocator.html"><code>NearestNodeLocators</code></a> held by <a href="../geomsearch/GeometricSearchData.html"><code>GeometricSearchData</code></a> objects in the <a href="../problems/FEProblemBase.html"><code>FEProblemBase</code></a> and <a href="../problems/DisplacedProblem.html"><code>DisplacedProblem</code></a> (the latter only if there are mesh displacements). In the future sparsity augmentation from constraints will occur through <a href="../relationshipmanagers/RelationshipManager.html"><code>RelationshipManagers</code></a> instead of through the <code>augmentSparsity</code> method.</p></section><section class="scrollspy" id="b075cc4d-2264-4b7e-a7c7-3d1376493b8b" data-section-level="2" data-section-text="Computing Residual and Jacobian Together"><h2 id="resid_and_jac_together">Computing Residual and Jacobian Together</h2><p>The default behavior in MOOSE is to have separate functions compute the residual and Jacobian. However, with the advent of <a href="NonlinearSystem.html#AD">Automatic Differentiation</a> it can make sense to use a single function to compute the residual and Jacobian simultaneously. At the local residual object level, automatic differentiation (AD) already computes the residual and Jacobian simultaneously, with the dual number at the core of AD holding value (residual) and derivatives (Jacobian). Simultaneous evaluation of residual and Jacobian using a single function can be triggered by setting <a href="#a9f731b9-fb23-41ff-acf8-f4646a5d5b77" class="moose-modal-link modal-trigger">&quot;residual_and_jacobian_together&quot;</a> to <code>true</code>. What this does in the background is funnels the (generally AD) computed local residuals and Jacobians into the global residual vector and Jacobian matrix respectively when PETSc calls the libMesh/MOOSE residual/function evaluation routine. Then when PETSc calls the libMesh/MOOSE Jacobian evaluation routine, we simply return because the global matrix has already been computed.</p><p>Computing the residual and Jacobian together has shown 20% gains for Navier-Stokes finite volume simulations for which automatic differentiation is leveraged even during standard residual evaluations. Other areas where computing the residual and Jacobian together may be advantageous is in simulations in which there are quite a few nonlinear iterations per timestep, for which the cost of an additional Jacobian evaluation during the final residual evaluation is amortized. Also, simulations in which material property calculations are very expensive may be good candidates for computing the residual and Jacobian together.</p></section><section class="scrollspy" id="fb90133b-f9c5-4835-b3fc-6ff7318847b8" data-section-level="2" data-section-text="Reusing preconditioners"><h2 id="reuse_preconditioners">Reusing preconditioners</h2><p>The simple version of GMRES and other iterative methods converge only very slowly.  To improve convergence, PETSc and other iterative solver packages apply a <a href="https://en.wikipedia.org/wiki/Preconditioner">preconditioner</a> to the system of equations/sparse matrix before applying the iterative solver.</p><p>A great number of preconditioners exist, but  <a href="https://en.wikipedia.org/wiki/Multigrid_method">multigrid</a> methods are often among the best choices for problems without  significant hyperbolic character.   The HYPRE package,  specifically the  BoomerAMG preconditioner, is often a good choice for a preconditioner to condition the system of equations resulting from the MOOSE simulation.</p><p>A direct factorization of the sparse system of equations is a <em>very</em> good preconditioner.  An iterative method using the factorized matrix as a preconditioner will typically converge to machine precision in a single iteration.  However, as noted above, factorizing the sparse system of equations for a large simulation is numerically expensive.</p><p>One option is to form a preconditioner once and then reuse it to solve the linearized system many times.  The preconditioner can be carried over through nonlinear iterations and even across time steps.  MOOSE allows the user to do this with the <code>reuse_preconditioner</code> flag. Setting</p><pre class="moose-pre"><code class="language-text">
  reuse_preconditioner = true
  reuse_preconditioner_max_linear_its = 20
</code></pre><p>in the <code>[Executioner]</code> block will reuse the same preconditioner until the number of linear iterations required to solve the linearized system of equations exceeds 20.   If the number of linear iterations exceeds  <code>reuse_preconditioner_max_linear_its</code> the system does not immediately stop iterating on the current linearized system.  Instead it will continue until it either successfully solves the current system or reaches <code>l_max_its</code>.  It will then form a new  preconditioner for the next nonlinear iteration.</p><p>Using these parameters in combination with a direct factorization of the system can be very efficient.  The following is an example of how to direct PETSc and MOOSE to solve the equations with this combination:</p><pre class="moose-pre"><code class="language-text">
  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package -ksp_type&#x27;
  petsc_options_value = &#x27;lu superlu_dist gmres&#x27;

  reuse_preconditioner = true
  reuse_preconditioner_max_linear_its = 20
</code></pre><p>This solver strategy can be very effective when the system Jacobian does not change very much from nonlinear iteration to nonlinear iteration and/or from time step to time step.  The heuristic is also most effective when the cost of solving the linearized system is a large fraction of the total simulation time.  As such, it can be especially beneficial when using an expensive preconditioner, like a direct solver, as shown in this example.</p><p>There are two differences between <code>reuse_preconditioner</code> and  setting up preconditioner reuse directly in PETSc with the  <code>-snes_lag_preconditioner_persists</code> and <code>-snes_lag_preconditioner</code> options: 1. <code>-snes_lag_preconditioner X</code> will recalculate a new preconditioner    every X linear iterations, regardless of the progress of the linear solve.    <code>reuse_preconditioner_max_linear_its = X</code> will continue to reuse    the same preconditioner until the number of linear iterations     required to solve the linearized equations exceeds X. 2. By default libmesh deletes the PETSc <code>SNES</code> instance after each time    step.  This means that regardless of how the reuse options are set,    the solver cannot retain the preconditioner across time steps.  The    <code>reuse_preconditioner</code> alters this behavior to retain the <code>SNES</code>    instance so that preconditioner reuse can be carried across time    steps.</p><p>Preconditioner reuse is also different from modified Newton methods, which can be configured with the PETSc <code>-snes_lag_jacobian</code> and <code>-snes_lag_jacobian_persists</code> options.  Preconditioner reuse affects how PETSc solves the linearized system of equations formed at each nonlinear iteration.  Ideally, if the reused preconditioner achieves the requested <code>l_tol</code> precision before iterating more than <code>l_max_its</code> times, preconditioner reuse will not affect the convergence of the nonlinear iterations compared to a case with the  reuse option off.  As described above, preconditioner reuse aims to decrease the time required to solve the linearized equations at each nonlinear iteration by reducing the number of times the solver needs to setup the potentially-expensive linear preconditioner.</p><p>By contrast, modified Newton methods will affect the nonlinear convergence of the system without affecting how PETSc solves the linearized system of equations.  The goal of  modified Newton methods is to reduce the time required to solve the nonlinear equations by forming a new Jacobian matrix less often.</p><p>Put another way, preconditioner reuse aims to speed up solving the linear system of equations while modified Newton methods aim to  accelerate solving the nonlinear equations. </p></section></section><div class="moose-modal modal" id="aaf509dc-d4e5-4858-b7b4-794278ff1e01"><div class="modal-content"><h4>(moose/test/src/kernels/ADCoupledConvection.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ADCoupledConvection.h&quot;

registerMooseObject(&quot;MooseTestApp&quot;, ADCoupledConvection);

InputParameters
ADCoupledConvection::validParams()
{
  InputParameters params = ADKernel::validParams();
  params.addParam&lt;Real&gt;(&quot;scale&quot;, 1, &quot;Scaling coefficient&quot;);
  params.addRequiredCoupledVar(&quot;velocity_vector&quot;, &quot;Velocity Vector for the Convection ADKernel&quot;);
  return params;
}

ADCoupledConvection::ADCoupledConvection(const InputParameters &amp; parameters)
  : ADKernel(parameters),
    _velocity_vector(adCoupledGradient(&quot;velocity_vector&quot;)),
    _scale(getParam&lt;Real&gt;(&quot;scale&quot;))
{
}

ADReal
ADCoupledConvection::computeQpResidual()
{
  return _scale * _test[_i][_qp] * _velocity_vector[_qp] * _grad_u[_qp];
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="8ff922a7-5407-4ffc-b267-93ebc6dc6e59"><div class="modal-content"><h4>(moose/test/include/kernels/ADCoupledConvection.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;ADKernel.h&quot;

/**
 * Define the ADKernel for a convection operator that looks like:
 *
 * grad_some_var dot u&#x27;
 */
class ADCoupledConvection : public ADKernel
{
public:
  static InputParameters validParams();

  ADCoupledConvection(const InputParameters &amp; parameters);

protected:
  virtual ADReal computeQpResidual() override;

private:
  const ADVariableGradient &amp; _velocity_vector;

  const Real &amp; _scale;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="77ef4016-736b-40b6-8e31-d42e2d530585"><div class="modal-content"><h4>(moose/test/src/materials/ADCoupledMaterial.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ADCoupledMaterial.h&quot;

registerMooseObject(&quot;MooseTestApp&quot;, ADCoupledMaterial);

InputParameters
ADCoupledMaterial::validParams()
{
  InputParameters params = Material::validParams();
  params.addRequiredCoupledVar(&quot;coupled_var&quot;, &quot;A coupledvariable&quot;);
  params.addRequiredParam&lt;MaterialPropertyName&gt;(&quot;ad_mat_prop&quot;,
                                                &quot;Name of the ad property this material defines&quot;);
  params.addRequiredParam&lt;MaterialPropertyName&gt;(
      &quot;regular_mat_prop&quot;, &quot;Name of the regular property this material defines&quot;);
  return params;
}

ADCoupledMaterial::ADCoupledMaterial(const InputParameters &amp; parameters)
  : Material(parameters),
    _ad_mat_prop(declareADProperty&lt;Real&gt;(getParam&lt;MaterialPropertyName&gt;(&quot;ad_mat_prop&quot;))),
    _regular_mat_prop(declareProperty&lt;Real&gt;(getParam&lt;MaterialPropertyName&gt;(&quot;regular_mat_prop&quot;))),
    _coupled_var(adCoupledValue(&quot;coupled_var&quot;))
{
}

// Note that the structure of the two (uncommented) methods below are for testing purposes only;
// e.g. this material demonstrates that you get bad convergence when you drop the derivative
// information from the coupled variable. A production version of this material would look like
// this:
//
// // void
// ADCoupledMaterial::computeQpProperties()
// {
//   _ad_mat_prop[_qp] = 4.0 * _coupled_var[_qp];
// }

void
ADCoupledMaterial::computeQpProperties()
{
  _regular_mat_prop[_qp] = 4.0 * MetaPhysicL::raw_value(_coupled_var[_qp]);
  _ad_mat_prop[_qp] = 4.0 * _coupled_var[_qp];
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="c62b2d52-0176-40b7-b8a8-176038546033"><div class="modal-content"><h4>(moose/test/include/materials/ADCoupledMaterial.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;Material.h&quot;

/**
 * A material that couples a material property
 */
class ADCoupledMaterial : public Material
{
public:
  static InputParameters validParams();

  ADCoupledMaterial(const InputParameters &amp; parameters);

protected:
  virtual void computeQpProperties();

  ADMaterialProperty&lt;Real&gt; &amp; _ad_mat_prop;
  MaterialProperty&lt;Real&gt; &amp; _regular_mat_prop;

  const ADVariableValue &amp; _coupled_var;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="73cdd4b3-eef1-4ee4-a124-72f30b4b8d66"><div class="modal-content"><h4>(moose/test/src/kernels/ADMatDiffusionTest.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ADMatDiffusionTest.h&quot;

registerMooseObject(&quot;MooseTestApp&quot;, ADMatDiffusionTest);

InputParameters
ADMatDiffusionTest::validParams()
{
  InputParameters params = ADKernel::validParams();
  params.addParam&lt;MaterialPropertyName&gt;(
      &quot;ad_mat_prop&quot;, &quot;ad_diffusivity&quot;, &quot;the name of the AD material property we are going to use&quot;);
  params.addParam&lt;MaterialPropertyName&gt;(&quot;regular_mat_prop&quot;,
                                        &quot;regular_diffusivity&quot;,
                                        &quot;the name of the AD material property we are going to use&quot;);
  MooseEnum prop_to_use(&quot;AdAd  RegReg&quot;, &quot;AdAd&quot;);
  params.addParam&lt;MooseEnum&gt;(&quot;prop_to_use&quot;,
                             prop_to_use,
                             &quot;What type of property to use. The prefix indicates the getter type &quot;
                             &quot;in the kernel; the suffix indicates the declaration type in the &quot;
                             &quot;material.&quot;);
  return params;
}

ADMatDiffusionTest::ADMatDiffusionTest(const InputParameters &amp; parameters)
  : ADKernel(parameters),
    _ad_diff_from_ad_prop(getADMaterialProperty&lt;Real&gt;(&quot;ad_mat_prop&quot;)),
    _regular_diff_from_regular_prop(getMaterialProperty&lt;Real&gt;(&quot;regular_mat_prop&quot;)),
    _prop_to_use(getParam&lt;MooseEnum&gt;(&quot;prop_to_use&quot;))
{
  // check whether our has APIs work

  if (!hasADMaterialProperty&lt;Real&gt;(&quot;ad_mat_prop&quot;) &amp;&amp;
      !defaultADMaterialProperty&lt;Real&gt;(deducePropertyName(&quot;ad_mat_prop&quot;)))
    mooseError(&quot;It should be impossible to get an AD property without erroring and simultaneously &quot;
               &quot;be neither able to retrieve the property with &#x27;hasADMaterialProperty&#x27; nor through &quot;
               &quot;a default property&quot;);
  if (!hasMaterialProperty&lt;Real&gt;(&quot;regular_mat_prop&quot;) &amp;&amp;
      !defaultMaterialProperty&lt;Real&gt;(deducePropertyName(&quot;regular_mat_prop&quot;)))
    mooseError(
        &quot;It should be impossible to get a regular property without erroring and simultaneously &quot;
        &quot;be neither able to retrieve the property with &#x27;hasMaterialProperty&#x27; nor through &quot;
        &quot;a default property&quot;);
}

ADReal
ADMatDiffusionTest::computeQpResidual()
{
  if (_prop_to_use == &quot;AdAd&quot;)
    return _ad_diff_from_ad_prop[_qp] * _grad_test[_i][_qp] * _grad_u[_qp];
  else if (_prop_to_use == &quot;RegReg&quot;)
    return _regular_diff_from_regular_prop[_qp] * _grad_test[_i][_qp] * _grad_u[_qp];
  else
    mooseError(&quot;Oops&quot;);
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="ed5cc225-b8e1-4af5-9d85-7b628cdc2bc5"><div class="modal-content"><h4>(moose/test/include/kernels/ADMatDiffusionTest.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;ADKernel.h&quot;
#include &quot;MaterialProperty.h&quot;

class ADMatDiffusionTest : public ADKernel
{
public:
  static InputParameters validParams();

  ADMatDiffusionTest(const InputParameters &amp; parameters);

protected:
  virtual ADReal computeQpResidual();

  const ADMaterialProperty&lt;Real&gt; &amp; _ad_diff_from_ad_prop;
  const MaterialProperty&lt;Real&gt; &amp; _regular_diff_from_regular_prop;
  const MooseEnum _prop_to_use;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="a9f731b9-fb23-41ff-acf8-f4646a5d5b77"><div class="modal-content"><h4>residual_and_jacobian_together</h4><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether to compute the residual and Jacobian together.</p></div></div></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#4ae9f565-fa5b-48b6-ab77-51e6a2e0e9bd" class="tooltipped" data-position="left" data-tooltip="Solving Non - linear Systems">Solving Non - linear Systems</a></li><li><a href="#58c4f9d8-0ef1-4275-af16-dd5e1b2a5e53" class="tooltipped" data-position="left" data-tooltip="Jacobian Definition">Jacobian Definition</a></li><li><a href="#b2733b9a-2ed2-47b3-897b-a96f51964502" class="tooltipped" data-position="left" data-tooltip="Solving Linear Systems">Solving Linear Systems</a></li><li><a href="#bed4a055-5163-4db2-98a7-5a129191ea95" class="tooltipped" data-position="left" data-tooltip="Augmenting Sparsity">Augmenting Sparsity</a></li><li><a href="#b075cc4d-2264-4b7e-a7c7-3d1376493b8b" class="tooltipped" data-position="left" data-tooltip="Computing Residual and Jacobian Together">Computing Residual and Jacobian Together</a></li><li><a href="#fb90133b-f9c5-4835-b3fc-6ff7318847b8" class="tooltipped" data-position="left" data-tooltip="Reusing preconditioners">Reusing preconditioners</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>