<!DOCTYPE html><head><meta charset="UTF-8"><title>VCP | Zapdos</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/zapdos.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Zapdos</a><a href="https://github.com/shannon-lab/zapdos" class="right"><img src="../../media/framework/github-logo.png" alt="GitHub wordmark" class="github-mark"></img><img src="../../media/framework/github-mark.png" alt="GitHub logo" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="1eb53838-87d2-4cbb-8839-150d7e2c27fd" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="91223f58-4439-4884-983b-149339cf8a14" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="c3cb53f1-b03c-4fa9-98c8-abe332c7cfae" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#" class="sidenav-trigger" data-target="49319ebc-cc96-4963-b8fc-9d86164e2989"><i class="material-icons">menu</i></a><ul class="sidenav" id="49319ebc-cc96-4963-b8fc-9d86164e2989"><li><a href="#!" class="dropdown-trigger" data-target="8c8993c6-dd70-4131-9fec-0b3d54075239" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="d7a6c0e3-b2a4-48a5-bb28-b4956d779b6d" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="9f706e2f-fe28-41d1-8c47-4981818504f8" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="1eb53838-87d2-4cbb-8839-150d7e2c27fd"><li><a href="../../getting_started/installation.html">Installation</a></li><li><a href="../../getting_started/using_zapdos.html">Using Zapdos</a></li><li><a href="../../getting_started/zapdos_meshing.html">Generating Meshes</a></li><li><a href="../../tutorial/index.html">Tutorial Slides</a></li></ul><ul class="dropdown-content" id="91223f58-4439-4884-983b-149339cf8a14"><li><a href="../../syntax/zapdos_only.html">Zapdos Input Syntax</a></li><li><a href="../../syntax/index.html">Complete Code Syntax</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/libmesh/classes.html">libMesh Doxygen</a></li><li><a href="../../a-to-z.html">Zapdos A to Z Index</a></li><li><a href="../../examples/crane_examples.html">CRANE Examples</a></li><li><a href="../../development/contributing.html">Contributing Guidelines</a></li><li><a href="../../development/code_standards.html">Code Standards</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="c3cb53f1-b03c-4fa9-98c8-abe332c7cfae"><li><a href="https://github.com/shannon-lab/zapdos/discussions">Zapdos Discussions Forum</a></li><li><a href="../../development/zapdos_developer_info.html">Zapdos Developer Information</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussions Forum</a></li><li><a href="https://mooseframework.inl.gov/">MOOSE Homepage</a></li><li><a href="../../development/moose_developer_info.html">MOOSE Developer Information</a></li></ul><ul class="dropdown-content" id="8c8993c6-dd70-4131-9fec-0b3d54075239"><li><a href="../../getting_started/installation.html">Installation</a></li><li><a href="../../getting_started/using_zapdos.html">Using Zapdos</a></li><li><a href="../../getting_started/zapdos_meshing.html">Generating Meshes</a></li><li><a href="../../tutorial/index.html">Tutorial Slides</a></li></ul><ul class="dropdown-content" id="d7a6c0e3-b2a4-48a5-bb28-b4956d779b6d"><li><a href="../../syntax/zapdos_only.html">Zapdos Input Syntax</a></li><li><a href="../../syntax/index.html">Complete Code Syntax</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/libmesh/classes.html">libMesh Doxygen</a></li><li><a href="../../a-to-z.html">Zapdos A to Z Index</a></li><li><a href="../../examples/crane_examples.html">CRANE Examples</a></li><li><a href="../../development/contributing.html">Contributing Guidelines</a></li><li><a href="../../development/code_standards.html">Code Standards</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="9f706e2f-fe28-41d1-8c47-4981818504f8"><li><a href="https://github.com/shannon-lab/zapdos/discussions">Zapdos Discussions Forum</a></li><li><a href="../../development/zapdos_developer_info.html">Zapdos Developer Information</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussions Forum</a></li><li><a href="https://mooseframework.inl.gov/">MOOSE Homepage</a></li><li><a href="../../development/moose_developer_info.html">MOOSE Developer Information</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">preconditioners</span><a href="#" class="breadcrumb">VariableCondensationPreconditioner</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="0f34f526-236d-4147-bf2e-445b59596f98" data-section-level="1" data-section-text="VCP"><h1 id="vcp">VCP</h1><p>Variable condensation preconditioner (VCP) condenses out specified variable(s) from the Jacobian matrix and produces a system of equations with less unkowns to be solved by the underlying preconditioners.</p><section class="scrollspy" id="9c3768d3-9b4c-4737-a9b8-e50d97d54d32" data-section-level="2" data-section-text="Overview"><h2 id="overview">Overview</h2><p>The Variable Condensation Preconditioner (VCP) is designed to condense out variables from the linear system of equations and apply the preconditioner/solver on the reduced simplified system of equations. The development of VCP is motivated by the need to enable a broader range of robust and scalable preconditioners for problems that have a saddle point type of Jacobian. The saddle point type of Jacobian may come from different applications. One typical example is the enforcement of constraints using Lagrange multipliers. Its special numerical character prevents the usage of many scalable iterative solvers. To resolve this issue, a static condensation step is carried out in VCP to remove the Degree of Freedoms (DoFs) that are associated with the Lagrange multipliers.   This may result in an easy-to-solve system (sometimes it is positive definite ) which can be handled by a broader range of solvers/preconditioners with improved efficiency. With VCP, we can efficiently apply iterative solvers, e.g., BoomerAMG, to mortar-based mechanical contact problems.</p></section><section class="scrollspy" id="29691bd6-fe08-472c-9e3f-351b397677b9" data-section-level="2" data-section-text="System Simplification"><h2 id="system-simplification">System Simplification</h2><p>To illustrate the saddle point structure of the Jacobian matrix and how it can be simplified by static condensation of the Lagrange multiplier, we take the Jacobian matrix from a simple diffusion problem with equal value constraint as an example. The system of equations at a typical time step can be written as a block matrix as follows, <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-18d468cb-eac6-4f4b-8002-f1381e80a315"></span><span class="moose-katex-equation-number">(1)</span><script>var element = document.getElementById("moose-equation-18d468cb-eac6-4f4b-8002-f1381e80a315");katex.render("\t\\begin{bmatrix}   K_{1, ii} &  K_{1, ic} & & & \\\\   K_{1, ci} &  K_{1, cc} & & & M\\\\   & & K_{2, ii} &  K_{2, ic} & \\\\   & & K_{2, ci} &  K_{2, cc} & D\\\\   & M^{\\intercal}&  &  D^{\\intercal} & 0\\\\ \t\\end{bmatrix}_{} \t\\begin{bmatrix} \\Delta u_{1,i} \\\\ \\Delta u_{1,c} \\\\ \\Delta u_{2,i} \\\\ \\Delta u_{2,c} \\\\ \\Delta \\lambda \t\\end{bmatrix} = \t\\begin{bmatrix} \\Delta r_{1,i} \\\\ \\Delta r_{1,c} \\\\ \\Delta r_{2,i} \\\\ \\Delta r_{2,c} \\\\ 0 \t\\end{bmatrix} ", element, {displayMode:true,throwOnError:false});</script></span> Here, we omit the identifier of time for simplicity. The first subscript <span class="moose-katex-inline-equation" id="moose-equation-ee53bae6-0259-4af6-9b6e-78c2f24db99b"><script>var element = document.getElementById("moose-equation-ee53bae6-0259-4af6-9b6e-78c2f24db99b");katex.render("(\\cdot)_1", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-0638e93e-7b6a-4f06-851c-8627a544ac87"><script>var element = document.getElementById("moose-equation-0638e93e-7b6a-4f06-851c-8627a544ac87");katex.render("(\\cdot)_2", element, {displayMode:false,throwOnError:false});</script></span> denote the primary and secondary subdomains, respectively. The second subscript <span class="moose-katex-inline-equation" id="moose-equation-5152da86-a7cb-44d7-a318-dd75c63d6dad"><script>var element = document.getElementById("moose-equation-5152da86-a7cb-44d7-a318-dd75c63d6dad");katex.render("(\\cdot)_{\\cdot, c}", element, {displayMode:false,throwOnError:false});</script></span> denotes the part of the subdomain that is in contact and <span class="moose-katex-inline-equation" id="moose-equation-03152ccc-c982-4120-a27e-61c937baf85a"><script>var element = document.getElementById("moose-equation-03152ccc-c982-4120-a27e-61c937baf85a");katex.render("(\\cdot)_{\\cdot, i}", element, {displayMode:false,throwOnError:false});</script></span> denotes the rest of the subdomain. The blocks <span class="moose-katex-inline-equation" id="moose-equation-aed47109-b7b4-45d0-b6cf-6cb5cd6ec848"><script>var element = document.getElementById("moose-equation-aed47109-b7b4-45d0-b6cf-6cb5cd6ec848");katex.render("K_{\\cdot, \\cdot}", element, {displayMode:false,throwOnError:false});</script></span> denote the respective stiffness matrices. The block <span class="moose-katex-inline-equation" id="moose-equation-ad45908a-1f3c-4412-8b69-93a820e5d43d"><script>var element = document.getElementById("moose-equation-ad45908a-1f3c-4412-8b69-93a820e5d43d");katex.render("D", element, {displayMode:false,throwOnError:false});</script></span> represents the coupling between the Lagrange multipliers and the primal variable in the secondary subdomain. The block <span class="moose-katex-inline-equation" id="moose-equation-64659ccb-a948-49b5-b7e2-8e2bbc4ab6fb"><script>var element = document.getElementById("moose-equation-64659ccb-a948-49b5-b7e2-8e2bbc4ab6fb");katex.render("M", element, {displayMode:false,throwOnError:false});</script></span> denotes the coupling between the Lagrange multipliers and the primal variable in the primary subdomain.</p><p>The system of equations from mortar-based mechanical contact has a similar saddle point character, but is more complex than <a href="#moose-equation-18d468cb-eac6-4f4b-8002-f1381e80a315">Eq. (1)</a>, considering the primary and secondary surfaces being partially in contact. For readers who are interested in the Jacobian matrix from mortar-based mechanical contact, please refer to (<a href="#popp2010dual">Popp et al., 2010</a>).</p><section id="8152a035-bb76-4c41-9c49-65af5f774a39" data-section-level="3" data-section-text="Condensation of the Lagrange Multiplier"><h3 id="condensation-of-the-lagrange-multiplier">Condensation of the Lagrange Multiplier</h3><p>The discrete Lagrange multipliers (i.e., <span class="moose-katex-inline-equation" id="moose-equation-2b2d9b90-88b1-4fe7-a015-54417d9d9c9c"><script>var element = document.getElementById("moose-equation-2b2d9b90-88b1-4fe7-a015-54417d9d9c9c");katex.render("\\Delta \\lambda", element, {displayMode:false,throwOnError:false});</script></span>) can be eliminated by condensation as follows, <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-0552fbe7-4c43-455c-bfe8-fa5eb8926012"></span><span class="moose-katex-equation-number">(2)</span><script>var element = document.getElementById("moose-equation-0552fbe7-4c43-455c-bfe8-fa5eb8926012");katex.render("\\Delta \\lambda = D^{-1}(\\Delta r_{2,c}-K_{2,ci} \\Delta u_{2,i}-K_{2,cc} \\Delta u_{2,c}). ", element, {displayMode:true,throwOnError:false});</script></span></p><p>By substituting <a href="#moose-equation-0552fbe7-4c43-455c-bfe8-fa5eb8926012">Eq. (2)</a> into <a href="#moose-equation-18d468cb-eac6-4f4b-8002-f1381e80a315">Eq. (1)</a>, we obtain a simplified linear system of equations that  contains only the primal variable DOFs,</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-81835f6f-2c66-429d-bbf4-f86f92176552"></span><span class="moose-katex-equation-number">(3)</span><script>var element = document.getElementById("moose-equation-81835f6f-2c66-429d-bbf4-f86f92176552");katex.render("\t\\begin{bmatrix}   K_{1, ii} &  K_{1, ic} & & \\\\   K_{1, ci} &  K_{1, cc} & -MD^{-1}K_{2,ii} &  -MD^{-1}K_{2,cc} \\\\   &  & K_{2, ii} &  K_{2, ic} \\\\   & M^{\\intercal}&  &  D^{\\intercal}\\\\ \t\\end{bmatrix} \t\\begin{bmatrix} \\Delta u_{1,i} \\\\ \\Delta u_{1,c} \\\\ \\Delta u_{2,i} \\\\ \\Delta u_{2,c} \t\\end{bmatrix} = \t\\begin{bmatrix} \\Delta r_{1,i} \\\\ \\Delta r_{1,c} - MD^{-1}\\Delta r_{2,c} \\\\ \\Delta r_{2,i} \\\\ 0 \t\\end{bmatrix} ", element, {displayMode:true,throwOnError:false});</script></span> This condensed system (i.e., <a href="#moose-equation-81835f6f-2c66-429d-bbf4-f86f92176552">Eq. (3)</a>) is positive definite and therefore state-of-art iterative solution techniques, such as multigrid methods, are applicable. As a post-processing step, the Lagrange multipliers can be recovered from the displacement following <a href="#moose-equation-0552fbe7-4c43-455c-bfe8-fa5eb8926012">Eq. (2)</a>.</p></section><section id="66e3806c-91a0-4c3e-9463-e6b483a1c396" data-section-level="3" data-section-text="Dual Basis Function"><h3 id="dual-basis-function">Dual Basis Function</h3><p>The computation of <span class="moose-katex-inline-equation" id="moose-equation-82563918-8431-406b-a0f5-864f49859482"><script>var element = document.getElementById("moose-equation-82563918-8431-406b-a0f5-864f49859482");katex.render("D^{-1}", element, {displayMode:false,throwOnError:false});</script></span> in <a href="#moose-equation-0552fbe7-4c43-455c-bfe8-fa5eb8926012">Eq. (2)</a> and <a href="#moose-equation-81835f6f-2c66-429d-bbf4-f86f92176552">Eq. (3)</a> can be reduced by using <strong>dual basis</strong> for the Lagrange multipliers. The <strong>dual basis</strong> is a relative definition to the <strong>standard basis</strong>, which satisfies a biorthogonal condition as follows <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-85c4a8d9-6df1-4f6e-baa3-653e1cb670fd"></span><span class="moose-katex-equation-number">(4)</span><script>var element = document.getElementById("moose-equation-85c4a8d9-6df1-4f6e-baa3-653e1cb670fd");katex.render(" \t\\int_{\\Gamma_e} \\psi_j (\\boldsymbol{x}) \\phi_k(\\boldsymbol{x})~\\text{d}s = \\delta_{jk} \\int_{\\Gamma_e} \\phi_k(\\boldsymbol{x})~\\text{d}s,", element, {displayMode:true,throwOnError:false});</script></span> where <span class="moose-katex-inline-equation" id="moose-equation-9f2543ae-b7b1-4d0b-bcea-61dcd3a252d5"><script>var element = document.getElementById("moose-equation-9f2543ae-b7b1-4d0b-bcea-61dcd3a252d5");katex.render("\\phi_k(\\boldsymbol{x})", element, {displayMode:false,throwOnError:false});</script></span> is the standard shape function, <span class="moose-katex-inline-equation" id="moose-equation-f08e2534-27c4-48f6-b503-7e7a2c0d5b99"><script>var element = document.getElementById("moose-equation-f08e2534-27c4-48f6-b503-7e7a2c0d5b99");katex.render("\\psi_j (\\boldsymbol{x})", element, {displayMode:false,throwOnError:false});</script></span> is the dual shape function, and <span class="moose-katex-inline-equation" id="moose-equation-10f152a2-133a-4653-a9b0-047df8ab99c9"><script>var element = document.getElementById("moose-equation-10f152a2-133a-4653-a9b0-047df8ab99c9");katex.render("\\delta_{jk}", element, {displayMode:false,throwOnError:false});</script></span> is the Kronecker delta function. This biorthogonal condition can be assumed to hold in every lower-dimensional element <span class="moose-katex-inline-equation" id="moose-equation-e2bee278-f8eb-47ee-9e1b-e8fd5a47c376"><script>var element = document.getElementById("moose-equation-e2bee278-f8eb-47ee-9e1b-e8fd5a47c376");katex.render("\\Gamma_e", element, {displayMode:false,throwOnError:false});</script></span>. Owing to the biorthogonality property of the <strong>dual basis</strong> functions, the integral matrix <span class="moose-katex-inline-equation" id="moose-equation-51628ff1-4a38-4864-847d-bf201bf3d428"><script>var element = document.getElementById("moose-equation-51628ff1-4a38-4864-847d-bf201bf3d428");katex.render("D", element, {displayMode:false,throwOnError:false});</script></span> become strict diagonal. Thus computation of <span class="moose-katex-inline-equation" id="moose-equation-c4f1db48-a4f1-4ff8-94d1-042727f2f0c4"><script>var element = document.getElementById("moose-equation-c4f1db48-a4f1-4ff8-94d1-042727f2f0c4");katex.render("D^{-1}", element, {displayMode:false,throwOnError:false});</script></span> and condensation steps in <a href="#moose-equation-0552fbe7-4c43-455c-bfe8-fa5eb8926012">Eq. (2)</a> and <a href="#moose-equation-81835f6f-2c66-429d-bbf4-f86f92176552">Eq. (3)</a> become trivial.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note:</span>Use of dual basis is optional but recommended</div><div class="card-content"><div class="moose-alert-content"><p>In order to reduce the computational cost brought by the condensation steps (see <a href="#moose-equation-0552fbe7-4c43-455c-bfe8-fa5eb8926012">Eq. (2)</a> and <a href="#moose-equation-81835f6f-2c66-429d-bbf4-f86f92176552">Eq. (3)</a>), we recommend the usage of <strong>dual basis</strong> function for the Lagrange multipliers. Meanwhile, we suggest setting the option <code>is_lm_coupling_diagonal = true</code> in the preconditioning block to let VCP take the diagonal structure of the couple matrix (<span class="moose-katex-inline-equation" id="moose-equation-70959bec-91ce-4b59-ae00-573abe1c8b92"><script>var element = document.getElementById("moose-equation-70959bec-91ce-4b59-ae00-573abe1c8b92");katex.render("D", element, {displayMode:false,throwOnError:false});</script></span>) into account for improved efficiency. If D is not diagonal, but the number of multiplier DoFs is small, VCP will be still beneficial. It may be expensive to compute non-diagonal D when the number of multiplier DOFs is large.</p></div></div></div><p>One can enable the usage of <strong>dual basis</strong> by enabling <code>use_dual = true</code> in the <code>Variables</code> block:</p><pre style="max-height:350px;"><code class="language-text">
[Variables]
 [./lm]
   order = FIRST
   family = LAGRANGE
   use_dual = true
 [../]
[]
</code></pre><p>Or, for mortar-based contact problems, the dual basis function is used <strong>by default</strong> for the Lagrange multipliers (while using the contact action). An example input block for contact action is as follows:</p><pre style="max-height:350px;"><code class="language-moose">[Contact]
  [frictionless]
    primary = plank_right
    secondary = block_left
    formulation = mortar
    c_normal = 1e0
  []
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#3cc64574-37d2-4f5d-9038-2d774343483e">(moose/modules/contact/test/tests/mortar_tm/2d/frictionless_first/small.i)</a></section></section><section class="scrollspy" id="0cc9e3e8-977c-4a3b-ab34-7915eb837204" data-section-level="2" data-section-text="VCP Workflow"><h2 id="vcp-workflow">VCP Workflow</h2><p>A schematic is included in <a href="#VCP_scheme">Figure 1</a> to demonstrate the solution process of VCP. Compared to the standard precondition and solve procedure, VCP features two additional customized computation steps (i.e., one to condense out the variable and the other to obtain the full solution vector) (see <a href="#VCP_scheme">Figure 1</a>). During static condensation of the variable (e.g., <span class="moose-katex-inline-equation" id="moose-equation-898e3a18-0eda-4648-9686-3869e94b2105"><script>var element = document.getElementById("moose-equation-898e3a18-0eda-4648-9686-3869e94b2105");katex.render("\\Delta \\lambda", element, {displayMode:false,throwOnError:false});</script></span>), the DoFs are obtained for both the variable itself (<span class="moose-katex-inline-equation" id="moose-equation-a1ed4930-1090-4ee2-8b7c-15f57956f189"><script>var element = document.getElementById("moose-equation-a1ed4930-1090-4ee2-8b7c-15f57956f189");katex.render("\\Delta \\lambda", element, {displayMode:false,throwOnError:false});</script></span>) and its coupled variable (<span class="moose-katex-inline-equation" id="moose-equation-1a349fca-e527-40ca-99ec-68b0bbd4ea12"><script>var element = document.getElementById("moose-equation-1a349fca-e527-40ca-99ec-68b0bbd4ea12");katex.render("\\Delta u", element, {displayMode:false,throwOnError:false});</script></span>). Based on this information, the coupling matrices (i.e., <span class="moose-katex-inline-equation" id="moose-equation-783406bd-7931-462f-865a-3352533512b9"><script>var element = document.getElementById("moose-equation-783406bd-7931-462f-865a-3352533512b9");katex.render("D", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-0c880de9-13d7-4f34-9f41-8fc917258d34"><script>var element = document.getElementById("moose-equation-0c880de9-13d7-4f34-9f41-8fc917258d34");katex.render("M", element, {displayMode:false,throwOnError:false});</script></span>) will be extracted from the original Jacobian matrix. Then a reduced system of equations will be obtained with the necessary submatrix operations following <a href="#moose-equation-81835f6f-2c66-429d-bbf4-f86f92176552">Eq. (3)</a>. After solving the reduced system of equations, we obtain the primal variable solution vector, which is then utilized to update the variable <span class="moose-katex-inline-equation" id="moose-equation-43f14326-b667-4e78-92a5-376539338ee1"><script>var element = document.getElementById("moose-equation-43f14326-b667-4e78-92a5-376539338ee1");katex.render("\\Delta \\lambda", element, {displayMode:false,throwOnError:false});</script></span> (see <a href="#moose-equation-0552fbe7-4c43-455c-bfe8-fa5eb8926012">Eq. (2)</a>) and assemble the full solution vector.</p><div class="card moose-float" style="display:block;margin-left:auto;margin-right:auto;width:70%" id="VCP_scheme"><div class="card-content"><picture class="materialboxed moose-image" role="button" tabindex="0"><img src="../../large_media/preconditioning/VCP_Scheme.png" alt="The variable condensation preconditioner (VCP) workflow. Blue represents the original preconditioning steps. Orange shows the additional steps customized for VCP."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 1: </span><span class="moose-caption-text" id="VCP_scheme">The variable condensation preconditioner (VCP) workflow. Blue represents the original preconditioning steps. Orange shows the additional steps customized for VCP.</span></p></div></div><section id="746b3568-9c6a-4ec8-aa1a-01698e0fa66c" data-section-level="3" data-section-text="Special Designs in VCP"><h3 id="special-designs-in-vcp">Special Designs in VCP</h3><p>Several special designs in VCP foster improved performance:</p><ul class="browser-default"><li><p><strong>Adaptive variable condensation</strong>  The  idea  is  to  obtain  the  actual  DoFs  that  have  zero  diagonal entries by checking the Jacobian matrix at runtime.  This refines the DoF list such that variable condensation will only be carried out for those DoFs that actually result in a saddle point structure. For contact problems, this will make sure that variable condensation will only happen when the material bodies come into contact. One can optionally turn on/off this capability by setting the <code>adaptive_condensation = true</code> or <code>false</code>.</p><p></p></li><li><p><strong>Standard basis</strong> As mentioned above, we recommend the usage of dual basis to reduce computational overhead due to the condensation step. However, it can happen if the dual basis does not work for certain problems. In this case, the user can set <code>use_dual = false</code> to use the standard basis functions. Then <span class="moose-katex-inline-equation" id="moose-equation-81fddad4-3206-42f4-91ad-7739dadb3892"><script>var element = document.getElementById("moose-equation-81fddad4-3206-42f4-91ad-7739dadb3892");katex.render("D", element, {displayMode:false,throwOnError:false});</script></span> has off-diagonal entries. During the computation of <span class="moose-katex-inline-equation" id="moose-equation-e7d9c452-9a77-4ca7-9d84-1771b5b37390"><script>var element = document.getElementById("moose-equation-e7d9c452-9a77-4ca7-9d84-1771b5b37390");katex.render("{D}^{-1}", element, {displayMode:false,throwOnError:false});</script></span>, the user can choose to either use an LU solver (by setting <code>is_lm_coupling_diagonal = false</code>) or obtain an approximated inverse using the diagonal entries (by setting <code>is_lm_coupling_diagonal = true</code>).</p><p></p></li><li><p><strong>Generalized condensation</strong> Although we are focused on using VCP for mortar-based contact problems with a saddle point structure, VCP is developed to be applicable to general problems in which improved conditioning is achievable via a reduced number of DoFs.</p></li></ul><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note:</span>Generalized variable condensation is not fully tested</div><div class="card-content"><div class="moose-alert-content"><p>VCP acts on the discretized system of equations and is designed to be as general as possible. However, the current implementation is mainly tested for mortar-based mechanical contact problems. We are actively improving this implementation and are looking for applications beyond contact. Therefore, please feel free to <a href="https://github.com/idaholab/moose/issues">create an issue</a> or <a href="https://github.com/idaholab/moose/discussions">start a discussion</a> if you may come across any problem with VCP.</p></div></div></div></section></section><section class="scrollspy" id="84675c45-863e-46a2-88c9-ad06b52fc899" data-section-level="2" data-section-text="Performance"><h2 id="performance">Performance</h2><p>As an illustration, we solve the 2D Hertzian problem by using VCP with several sub-preconditioner types, including BoomerAMG (AMG), successive over-relaxation (SOR), additive Schwarz method (ASM), and block Jacobi (BJAC). For all the cases, we set <code>adaptive_condensation = true</code> and <code>is_lm_coupling_diagonal = true</code>. Note that here, ASM, and BJAC converge for the mortar-based mechanical contact problem, both as a standalone preconditioner and as a sub-preconditioner. AMG and SOR stagnate as a standalone preconditioner, while converge well as a sub-preconditioner under VCP.  <a href="#hertzian_vcp_performance">Figure 2</a> shows the performance of VCP in terms of total wall time and total number of linear iterations. It can be seen that VCP can pretty efficiently converge using AMG and SOR, whereas the standard preconditioner stagnates or diverges. For the other sub-preconditioner types, VCP is still more efficient than the standard preconditioner, despite the additional computational cost from the variable condensation step. This is because a better-conditioned system is obtained after static condensation of the Lagrange multipliers. For readers who are interested in getting more details, please refer to (<a href="#yushu2021m3">Yushu et al., 2021</a>). Note the performance of VCP for problems with increased complexities, e.g., larger, multi-physics problems, is to be examined in the future.</p><div class="card moose-float" style="display:block;margin-left:auto;margin-right:auto;width:85%" id="hertzian_vcp_performance"><div class="card-content"><picture class="materialboxed moose-image" role="button" tabindex="0"><img src="../../large_media/preconditioning/Hertzian_vcp_performance.png" alt="Performance of VCP for the Hertzian problem.  Different sub-preconditioner types are utilized for comparison. Results are shown for four processors. Note the “inf.” identifies the case when the solver stagnates thus the wall time and total number of iterations go to infinity."></img></picture><p class="moose-caption"><span class="moose-caption-heading">Figure 2: </span><span class="moose-caption-text" id="hertzian_vcp_performance">Performance of VCP for the Hertzian problem.  Different sub-preconditioner types are utilized for comparison. Results are shown for four processors. Note the “inf.” identifies the case when the solver stagnates thus the wall time and total number of iterations go to infinity.</span></p></div></div></section><section class="scrollspy" id="8b9197cf-2691-4f03-b04a-c85496e0db34" data-section-level="2" data-section-text="Example Input File Syntax"><h2 id="example-input-file-syntax">Example Input File Syntax</h2><pre style="max-height:350px;"><code class="language-moose">[Preconditioning&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/Preconditioning/index.html&quot;}&gt;&gt;&gt;]
  [vcp]
    type = VCP&lt;&lt;&lt;{&quot;description&quot;: &quot;Variable condensation preconditioner (VCP) condenses out specified variable(s) from the Jacobian matrix and produces a system of equations with less unkowns to be solved by the underlying preconditioners.&quot;, &quot;href&quot;: &quot;VariableCondensationPreconditioner.html&quot;}&gt;&gt;&gt;
    full&lt;&lt;&lt;{&quot;description&quot;: &quot;Set to true if you want the full set of couplings between variables simply for convenience so you don&#x27;t have to set every off_diag_row and off_diag_column combination.&quot;}&gt;&gt;&gt; = true
    lm_variable&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the variable(s) that is to be condensed out. Usually this will be the Lagrange multiplier variable(s).&quot;}&gt;&gt;&gt; = &#x27;leftright_normal_lm&#x27;
    primary_variable&lt;&lt;&lt;{&quot;description&quot;: &quot;Name of the variable(s) that couples with the variable(s) specified in the `variable` block. Usually this is the primary variable that the Lagrange multiplier correspond to.&quot;}&gt;&gt;&gt; = &#x27;disp_x&#x27;
    preconditioner&lt;&lt;&lt;{&quot;description&quot;: &quot;Preconditioner type.&quot;}&gt;&gt;&gt; = &#x27;AMG&#x27;
    is_lm_coupling_diagonal&lt;&lt;&lt;{&quot;description&quot;: &quot;Set to true if you are sure the coupling matrix between Lagrange multiplier variable and the coupled primal variable is strict diagonal. This will speedup the linear solve. Otherwise set to false to ensure linear solve accuracy.&quot;}&gt;&gt;&gt; = true
    adaptive_condensation&lt;&lt;&lt;{&quot;description&quot;: &quot;By default VCP will check the Jacobian and only condense the rows with zero diagonals. Set to false if you want to condense out all the specified variable dofs.&quot;}&gt;&gt;&gt; = true
  []
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#e096cdca-5a4a-4a30-bbe9-a05a97be0dbb">(moose/modules/contact/test/tests/dual_mortar/dm_mechanical_contact_precon.i)</a></section><section class="scrollspy" id="94f2ff01-a42f-4f0f-91d8-1deae44713ab" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="fe696799-555d-436a-8799-709a0b361d86" data-section-level="3" data-section-text="Required Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">lm_variable</span><span class="moose-parameter-header-description">Name of the variable(s) that is to be condensed out. Usually this will be the Lagrange multiplier variable(s).</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Name of the variable(s) that is to be condensed out. Usually this will be the Lagrange multiplier variable(s).</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">preconditioner</span><span class="moose-parameter-header-description">Preconditioner type.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Preconditioner type.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">primary_variable</span><span class="moose-parameter-header-description">Name of the variable(s) that couples with the variable(s) specified in the `variable` block. Usually this is the primary variable that the Lagrange multiplier correspond to.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Name of the variable(s) that couples with the variable(s) specified in the `variable` block. Usually this is the primary variable that the Lagrange multiplier correspond to.</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Required Parameters</h3></summary></details></section><section id="5549543d-1e3c-4797-a29a-8f2aa0235138" data-section-level="3" data-section-text="Optional Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">adaptive_condensation</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">By default VCP will check the Jacobian and only condense the rows with zero diagonals. Set to false if you want to condense out all the specified variable dofs.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>By default VCP will check the Jacobian and only condense the rows with zero diagonals. Set to false if you want to condense out all the specified variable dofs.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">coupled_groups</span><span class="moose-parameter-header-description">List multiple space separated groups of comma separated variables. Off-diagonal jacobians will be generated for all pairs within a group.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;NonlinearVariableName&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>List multiple space separated groups of comma separated variables. Off-diagonal jacobians will be generated for all pairs within a group.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">full</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Set to true if you want the full set of couplings between variables simply for convenience so you don't have to set every off_diag_row and off_diag_column combination.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Set to true if you want the full set of couplings between variables simply for convenience so you don't have to set every off_diag_row and off_diag_column combination.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">is_lm_coupling_diagonal</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Set to true if you are sure the coupling matrix between Lagrange multiplier variable and the coupled primal variable is strict diagonal. This will speedup the linear solve. Otherwise set to false to ensure linear solve accuracy.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Set to true if you are sure the coupling matrix between Lagrange multiplier variable and the coupled primal variable is strict diagonal. This will speedup the linear solve. Otherwise set to false to ensure linear solve accuracy.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">ksp_norm</span><span class="moose-parameter-header-default">unpreconditioned</span><span class="moose-parameter-header-description">Sets the norm that is used for convergence testing</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>unpreconditioned</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>none, preconditioned, unpreconditioned, natural, default</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Sets the norm that is used for convergence testing</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">nl_sys</span><span class="moose-parameter-header-description">The nonlinear system whose linearization this preconditioner should be applied to.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>NonlinearSystemName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The nonlinear system whose linearization this preconditioner should be applied to.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">off_diag_column</span><span class="moose-parameter-header-description">The variable names for the off-diagonal columns you want to add into the matrix; they will be associated with an off-diagonal row from the same position in off_diag_row.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;NonlinearVariableName&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The variable names for the off-diagonal columns you want to add into the matrix; they will be associated with an off-diagonal row from the same position in off_diag_row.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">off_diag_row</span><span class="moose-parameter-header-description">The variable names for the off-diagonal rows you want to add into the matrix; they will be associated with an off-diagonal column from the same position in off_diag_column.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;NonlinearVariableName&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The variable names for the off-diagonal rows you want to add into the matrix; they will be associated with an off-diagonal column from the same position in off_diag_column.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">pc_side</span><span class="moose-parameter-header-default">default</span><span class="moose-parameter-header-description">Preconditioning side</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>default</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>left, right, symmetric, default</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Preconditioning side</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="061dbfc9-f103-4baa-85e0-32ae7687f93f" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section><section id="a57e631e-a2ad-49d6-95ce-4a5092d9b5d4" data-section-level="3" data-section-text="Petsc Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">mffd_type</span><span class="moose-parameter-header-default">wp</span><span class="moose-parameter-header-description">Specifies the finite differencing type for Jacobian-free solve types. Note that the default is wp (for Walker and Pernice).</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>wp</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>wp, ds</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Specifies the finite differencing type for Jacobian-free solve types. Note that the default is wp (for Walker and Pernice).</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">petsc_options</span><span class="moose-parameter-header-description">Singleton PETSc options</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MultiMooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>-dm_moose_print_embedding, -dm_view, -KSP_CONVERGED_REASON, -KSP_GMRES_MODIFIEDGRAMSCHMIDT, -KSP_MONITOR, -KSP_MONITOR_SNES_LG, -SNES_KSP_EW, -SNES_CONVERGED_REASON, -SNES_KSP, -SNES_LINESEARCH_MONITOR, -SNES_MF, -SNES_MF_OPERATOR, -SNES_MONITOR, -SNES_TEST_DISPLAY, -SNES_VIEW, -SNES_MONITOR_CANCEL</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Singleton PETSc options</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">petsc_options_iname</span><span class="moose-parameter-header-description">Names of PETSc name/value pairs</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MultiMooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>-mat_fd_coloring_err, -mat_fd_type, -mat_mffd_type, -pc_asm_overlap, -pc_factor_levels, -pc_factor_mat_ordering_type, -pc_hypre_boomeramg_grid_sweeps_all, -pc_hypre_boomeramg_max_iter, -pc_hypre_boomeramg_strong_threshold, -pc_hypre_type, -pc_type, -sub_pc_type, -KSP_ATOL, -KSP_GMRES_RESTART, -KSP_MAX_IT, -KSP_PC_SIDE, -KSP_RTOL, -KSP_TYPE, -SUB_KSP_TYPE, -SNES_ATOL, -SNES_LINESEARCH_TYPE, -SNES_LS, -SNES_MAX_IT, -SNES_RTOL, -SNES_DIVERGENCE_TOLERANCE, -SNES_TYPE</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Names of PETSc name/value pairs</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">petsc_options_value</span><span class="moose-parameter-header-description">Values of PETSc name/value pairs (must correspond with "petsc_options_iname"</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Values of PETSc name/value pairs (must correspond with "petsc_options_iname"</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">solve_type</span><span class="moose-parameter-header-description">PJFNK: Preconditioned Jacobian-Free Newton Krylov JFNK: Jacobian-Free Newton Krylov NEWTON: Full Newton Solve FD: Use finite differences to compute Jacobian LINEAR: Solving a linear problem</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>PJFNK, JFNK, NEWTON, FD, LINEAR</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>PJFNK: Preconditioned Jacobian-Free Newton Krylov JFNK: Jacobian-Free Newton Krylov NEWTON: Full Newton Solve FD: Use finite differences to compute Jacobian LINEAR: Solving a linear problem</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Petsc Parameters</h3></summary></details></section></section><section class="scrollspy" id="d1e8d469-9d4c-4272-b0db-4bb135f4920c" data-section-level="2" data-section-text="References"><h2 id="references">References</h2><div class="moose-bibliography"><ol><li id="popp2010dual">Alexander Popp, Markus Gitterle, Michael&nbsp;W Gee, and Wolfgang&nbsp;A Wall.
A dual mortar approach for <span class="bibtex-protected">3D</span> finite deformation contact with consistent linearization.
<em>International Journal for Numerical Methods in Engineering</em>, 83(11):1428–1465, 2010.<a href="#e044ef02-ef23-494c-a7a2-950866f289e8" class="modal-trigger moose-bibtex-modal" style="padding-left:10px;">[BibTeX]</a><div class="modal" id="e044ef02-ef23-494c-a7a2-950866f289e8"><div class="modal-content"><pre style="line-height:1.25;"><code class="language-latex">@article{popp2010dual,
    author = "Popp, Alexander and Gitterle, Markus and Gee, Michael W and Wall, Wolfgang A",
    title = "A dual mortar approach for {3D} finite deformation contact with consistent linearization",
    journal = "International Journal for Numerical Methods in Engineering",
    volume = "83",
    number = "11",
    pages = "1428--1465",
    year = "2010",
    publisher = "Wiley Online Library"
}
</code></pre></div></div></li><li id="yushu2021m3">Dewen Yushu, Antonio Martin&nbsp;Recuero, Daniel Schwen, Alexander Lindsay, and Benjamin Spencer.
<span class="bibtex-protected">M3</span> milestone: advanced contact 2021.
2021.<a href="#413c8196-d537-4a76-81e7-6f391600278b" class="modal-trigger moose-bibtex-modal" style="padding-left:10px;">[BibTeX]</a><div class="modal" id="413c8196-d537-4a76-81e7-6f391600278b"><div class="modal-content"><pre style="line-height:1.25;"><code class="language-latex">@article{yushu2021m3,
    author = "Yushu, Dewen and Martin Recuero, Antonio and Schwen, Daniel and Lindsay, Alexander and Spencer, Benjamin",
    title = "{M3} milestone: Advanced contact 2021",
    place = "United States",
    year = "2021",
    journal = ""
}
</code></pre></div></div></li></ol></div></section></section><div class="moose-modal modal" id="3cc64574-37d2-4f5d-9038-2d774343483e"><div class="modal-content"><h4>(moose/modules/contact/test/tests/mortar_tm/2d/frictionless_first/small.i)</h4><pre style="max-height:350px;"><code class="language-moose">E_block = 1e7
E_plank = 1e7
elem = QUAD4
order = FIRST
name = &#x27;small&#x27;

[Mesh]
  patch_size = 80
  patch_update_strategy = auto
  [plank]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = -0.3
    xmax = 0.3
    ymin = -10
    ymax = 10
    nx = 2
    ny = 67
    elem_type = ${elem}
    boundary_name_prefix = plank
  []
  [plank_id]
    type = SubdomainIDGenerator
    input = plank
    subdomain_id = 1
  []

  [block]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = 0.31
    xmax = 0.91
    ymin = 7.7
    ymax = 8.5
    nx = 3
    ny = 4
    elem_type = ${elem}
    boundary_name_prefix = block
    boundary_id_offset = 10
  []
  [block_id]
    type = SubdomainIDGenerator
    input = block
    subdomain_id = 2
  []

  [combined]
    type = MeshCollectionGenerator
    inputs = &#x27;plank_id block_id&#x27;
  []
  [block_rename]
    type = RenameBlockGenerator
    input = combined
    old_block = &#x27;1 2&#x27;
    new_block = &#x27;plank block&#x27;
  []
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [disp_x]
    order = ${order}
    block = &#x27;plank block&#x27;
    scaling = &#x27;${fparse 2.0 / (E_plank + E_block)}&#x27;
  []
  [disp_y]
    order = ${order}
    block = &#x27;plank block&#x27;
    scaling = &#x27;${fparse 2.0 / (E_plank + E_block)}&#x27;
  []
[]

[Physics/SolidMechanics/QuasiStatic]
  [action]
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress hydrostatic_stress strain_xx &#x27;
                      &#x27;strain_yy strain_zz&#x27;
    block = &#x27;plank block&#x27;
  []
[]

[Contact]
  [frictionless]
    primary = plank_right
    secondary = block_left
    formulation = mortar
    c_normal = 1e0
  []
[]

[BCs]
  [left_x]
    type = DirichletBC
    variable = disp_x
    boundary = plank_left
    value = 0.0
  []
  [left_y]
    type = DirichletBC
    variable = disp_y
    boundary = plank_bottom
    value = 0.0
  []
  [right_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = block_right
    function = &#x27;-0.04*sin(4*(t+1.5))+0.02&#x27;
  []
  [right_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = block_right
    function = &#x27;-t&#x27;
  []
[]

[Materials]
  [plank]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;plank&#x27;
    poissons_ratio = 0.3
    youngs_modulus = ${E_plank}
  []
  [block]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;block&#x27;
    poissons_ratio = 0.3
    youngs_modulus = ${E_block}
  []
  [stress]
    type = ComputeLinearElasticStress
    block = &#x27;plank block&#x27;
  []
[]

[Preconditioning]
  [smp]
    type = SMP
    full = true
  []
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_converged_reason -ksp_converged_reason&#x27;
  petsc_options_iname = &#x27;-pc_type -mat_mffd_err -pc_factor_shift_type -pc_factor_shift_amount&#x27;
  petsc_options_value = &#x27;lu       1e-5          NONZERO               1e-15&#x27;
  end_time = 13.5
  dt = 0.1
  dtmin = 0.1
  timestep_tolerance = 1e-6
  line_search = &#x27;contact&#x27;
[]

[Postprocessors]
  [nl_its]
    type = NumNonlinearIterations
  []
  [total_nl_its]
    type = CumulativeValuePostprocessor
    postprocessor = nl_its
  []
  [l_its]
    type = NumLinearIterations
  []
  [total_l_its]
    type = CumulativeValuePostprocessor
    postprocessor = l_its
  []
  [contact]
    type = ContactDOFSetSize
    variable = frictionless_normal_lm
    subdomain = frictionless_secondary_subdomain
  []
  [avg_hydro]
    type = ElementAverageValue
    variable = hydrostatic_stress
    block = &#x27;block&#x27;
  []
  [max_hydro]
    type = ElementExtremeValue
    variable = hydrostatic_stress
    block = &#x27;block&#x27;
  []
  [min_hydro]
    type = ElementExtremeValue
    variable = hydrostatic_stress
    block = &#x27;block&#x27;
    value_type = min
  []
  [avg_vonmises]
    type = ElementAverageValue
    variable = vonmises_stress
    block = &#x27;block&#x27;
  []
  [max_vonmises]
    type = ElementExtremeValue
    variable = vonmises_stress
    block = &#x27;block&#x27;
  []
  [min_vonmises]
    type = ElementExtremeValue
    variable = vonmises_stress
    block = &#x27;block&#x27;
    value_type = min
  []
[]

[Outputs]
  file_base = ${name}
  [comp]
    type = CSV
    show = &#x27;contact&#x27;
  []
  [out]
    type = CSV
    file_base = &#x27;${name}_out&#x27;
  []
[]

[Debug]
  show_var_residual_norms = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="e096cdca-5a4a-4a30-bbe9-a05a97be0dbb"><div class="modal-content"><h4>(moose/modules/contact/test/tests/dual_mortar/dm_mechanical_contact_precon.i)</h4><pre style="max-height:350px;"><code class="language-moose">[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  [left_block]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = -1.05
    xmax = -0.05
    ymin = -1
    ymax = 0
    nx = 4
    ny = 8
    elem_type = QUAD4
  []
  [left_block_sidesets]
    type = RenameBoundaryGenerator
    input = left_block
    old_boundary = &#x27;0 1 2 3&#x27;
    new_boundary = &#x27;10 11 12 13&#x27;
  []
  [left_block_id]
    type = SubdomainIDGenerator
    input = left_block_sidesets
    subdomain_id = 1
  []
  [right_block]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = 0
    xmax = 1
    ymin = -1
    ymax = 1
    nx = 4
    ny = 8
    elem_type = QUAD4
  []
  [right_block_sidesets]
    type = RenameBoundaryGenerator
    input = right_block
    old_boundary = &#x27;0 1 2 3&#x27;
    new_boundary = &#x27;20 21 22 23&#x27;
  []
  [right_block_id]
    type = SubdomainIDGenerator
    input = right_block_sidesets
    subdomain_id = 2
  []

  [combined_mesh]
    type = MeshCollectionGenerator
    inputs = &#x27;left_block_id right_block_id&#x27;
  []
[]

[Physics/SolidMechanics/QuasiStatic]
  [all]
    strain = FINITE
    incremental = true
    add_variables = true
    block = &#x27;1 2&#x27;
  []
[]

[Functions]
  [horizontal_movement]
    type = PiecewiseLinear
    x =&#x27;0 0.5 2&#x27;
    y = &#x27;0 0.1 0.1&#x27;
  []
  [vertical_movement]
    type = PiecewiseLinear
    x =&#x27;0 0.5 2&#x27;
    y = &#x27;0.001 0.001 0.2&#x27;
  []
[]

[BCs]
  [push_left_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 13
    function = horizontal_movement
  []
  [fix_right_x]
    type = DirichletBC
    variable = disp_x
    boundary = 21
    value = 0.0
  []
  [fix_right_y]
    type = DirichletBC
    variable = disp_y
    boundary = 21
    value = 0.0
  []
  [push_left_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 13
    function = vertical_movement
  []
[]

[Materials]
  [elasticity_tensor_left]
    type = ComputeIsotropicElasticityTensor
    block = 1
    youngs_modulus = 1.0e6
    poissons_ratio = 0.3
  []
  [stress_left]
    type = ComputeFiniteStrainElasticStress
    block = 1
  []

  [elasticity_tensor_right]
    type = ComputeIsotropicElasticityTensor
    block = 2
    youngs_modulus = 1.0e6
    poissons_ratio = 0.3
  []
  [stress_right]
    type = ComputeFiniteStrainElasticStress
    block = 2
  []
[]

[Contact]
  [leftright]
    secondary = &#x27;11&#x27;
    primary = &#x27;23&#x27;
    formulation = mortar
    model = frictionless
  []
[]

[Preconditioning]
  [vcp]
    type = VCP
    full = true
    lm_variable = &#x27;leftright_normal_lm&#x27;
    primary_variable = &#x27;disp_x&#x27;
    preconditioner = &#x27;AMG&#x27;
    is_lm_coupling_diagonal = true
    adaptive_condensation = true
  []
[]

[Executioner]
  type = Transient
  solve_type = &#x27;NEWTON&#x27;

  petsc_options = &#x27;-snes_converged_reason -ksp_converged_reason -snes_view&#x27;

  dt = 0.2
  dtmin = 0.2
  end_time = 1.0

  l_max_its = 20

  nl_max_its = 8
  nl_rel_tol = 1e-6
  snesmf_reuse_base = false
[]

[Outputs]
  file_base = ./dm_contact_gmesh_out
  [comp]
    type = CSV
    show = &#x27;contact normal_lm avg_disp_x avg_disp_y max_disp_x max_disp_y min_disp_x min_disp_y&#x27;
    execute_on = &#x27;FINAL&#x27;
  []
[]

[Postprocessors]
  [contact]
    type = ContactDOFSetSize
    variable = leftright_normal_lm
    subdomain = leftright_secondary_subdomain
  []
  [normal_lm]
    type = ElementAverageValue
    variable = leftright_normal_lm
    block = leftright_secondary_subdomain
  []
  [avg_disp_x]
    type = ElementAverageValue
    variable = disp_x
    block = &#x27;1 2&#x27;
  []
  [avg_disp_y]
    type = ElementAverageValue
    variable = disp_y
    block = &#x27;1 2&#x27;
  []
  [max_disp_x]
    type = ElementExtremeValue
    variable = disp_x
    block = &#x27;1 2&#x27;
  []
  [max_disp_y]
    type = ElementExtremeValue
    variable = disp_y
    block = &#x27;1 2&#x27;
  []
  [min_disp_x]
    type = ElementExtremeValue
    variable = disp_x
    block = &#x27;1 2&#x27;
    value_type = min
  []
  [min_disp_y]
    type = ElementExtremeValue
    variable = disp_y
    block = &#x27;1 2&#x27;
    value_type = min
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#9c3768d3-9b4c-4737-a9b8-e50d97d54d32" class="tooltipped" data-position="left" data-tooltip="Overview">Overview</a></li><li><a href="#29691bd6-fe08-472c-9e3f-351b397677b9" class="tooltipped" data-position="left" data-tooltip="System Simplification">System Simplification</a></li><li><a href="#0cc9e3e8-977c-4a3b-ab34-7915eb837204" class="tooltipped" data-position="left" data-tooltip="VCP Workflow">VCP Workflow</a></li><li><a href="#84675c45-863e-46a2-88c9-ad06b52fc899" class="tooltipped" data-position="left" data-tooltip="Performance">Performance</a></li><li><a href="#8b9197cf-2691-4f03-b04a-c85496e0db34" class="tooltipped" data-position="left" data-tooltip="Example Input File Syntax">Example Input File Syntax</a></li><li><a href="#94f2ff01-a42f-4f0f-91d8-1deae44713ab" class="tooltipped" data-position="left" data-tooltip="Input Parameters">Input Parameters</a></li><li><a href="#d1e8d469-9d4c-4272-b0db-4bb135f4920c" class="tooltipped" data-position="left" data-tooltip="References">References</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script><script type="text/javascript" src="../../js/moose_input_parser.js"></script>